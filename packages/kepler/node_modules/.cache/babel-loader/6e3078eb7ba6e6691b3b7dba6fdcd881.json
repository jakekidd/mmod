{"ast":null,"code":"import * as THREE from \"three\";\nimport { MMOD_SCALE } from \"../helpers/Constants.ts\";\nimport { Random } from \"../helpers/Random.ts\";\nimport { Interpolate } from \"../helpers/Interpolate.ts\";\n// TODO: Move these to constants.\nconst MATERIAL_DENSITY_MAP = {\n  Metal: 7800,\n  // Density of metal in kg/m^3\n  Plastic: 950,\n  // Density of plastic in kg/m^3\n  Composite: 1600 // Density of composite in kg/m^3\n  // TODO: Add more materials as needed\n};\n/**\n * The gravitational parameter (μ) is a constant value for a particular\n * celestial body and represents the product of the gravitational constant (G) and the\n * mass (M) of the central body (usually a planet or a star). For Earth, μ is approximately\n * 3.986×10^14 m^3/s^2.\n */\nconst MU_EARTH = 3.986e14;\n// TODO: Move to constants\nconst PARITY = 1000 * 60 * 60; // 1 hour.\n\nexport class MMOD {\n  /**\n   * A small point object representing orbiting debris.\n   */\n  constructor(args) {\n    // The three js object to be rendered.\n    this.mesh = void 0;\n    this.position = void 0;\n    // TODO: Think on this one.\n    // Normally, a sequential nine-digit number assigned by the\n    // USSPACECOM in order of launch or discovery.\n    this.catalogNumber = 0;\n    // Keplerian orbital elements, plus some others used in\n    // producing the TLE representation.\n    // See: https://en.wikipedia.org/wiki/Orbital_elements\n    // Semi-major axis is the sum of the periapsis and apoapsis\n    // distances divided by two.\n    // public semiMajorAxis: number;\n    // Inclination is the vertical tilt of the ellipse with\n    // respect to the reference plane.\n    // public inclination: number;\n    // The right ascension of the ascending node is the angle\n    // from a specified reference direction, called the origin\n    // of longitude, to the direction of the ascending node.\n    // public longitude: number;\n    // Eccentricity represents the shape of the orbital ellipse,\n    // describing how much it is elongated compared to a circle.\n    // public eccentricity: number;\n    // The argument of perigee is, parametrically, the angle\n    // from the body's ascending node to its periapsis, measured\n    // in the direction of motion.\n    // public perigee: number;\n    // Mean motion is revolutions per day.\n    // public motion: number;\n    // Mean anomaly is the fraction of an elliptical orbit's\n    // period that has elapsed since the orbiting body passed\n    // periapsis.\n    // public anomaly: number;\n    // TODO: Again, think on this. Could be prohibitive, but\n    // maybe we can exclude from target consensus data model?\n    // Revolution number (typically at a given epoch) is just\n    // a counter, again normally tracked by\n    // This will not be tracked here.\n    this.revolution = 1;\n    // Will leave this at unclassified for now.\n    this.classification = \"U\";\n    // TODO: Comment this\n    this.orbit = void 0;\n    this.specs = void 0;\n    this.path = void 0;\n    // TODO: Move to constants.\n    // Constants\n    this.earthRadius = 6371;\n    // in km\n    this.shouldLog = false;\n    // TODO: test remove\n    // if (COUNT === 0) {\n    //   this.shouldLog = true;\n    // }\n    // COUNT++;\n\n    if (args && args.flight) {\n      this.orbit = args.flight.orbit;\n      this.specs = args.flight.specs;\n      this.position = {\n        x: args.flight.path[0].x,\n        y: args.flight.path[0].y,\n        z: args.flight.path[0].z\n      };\n      this.path = args.flight.path;\n    } else {\n      // Generate random position in low earth orbit\n      const altitude = Random.number(700, 2000); // altitude between 700-2000 km\n      const longitude = Random.number(0, 360); // random longitude\n      const latitude = Math.random() * 180 - 90; // random latitude\n\n      // Convert spherical coordinates to Cartesian coordinates\n      const x = (this.earthRadius + altitude) * Math.cos(latitude) * Math.cos(longitude);\n      const y = (this.earthRadius + altitude) * Math.cos(latitude) * Math.sin(longitude);\n      const z = (this.earthRadius + altitude) * Math.sin(latitude);\n      this.position = {\n        x,\n        y,\n        z\n      };\n\n      // Generate random elliptical orbit path\n      this.orbit = {\n        semiMajorAxis: Random.number(700, 2000),\n        // semi-major axis between 1300-2000 km\n        eccentricity: Random.number(0, 0.1),\n        // TODO: I think more common around 80-100..?\n        // Inclination between the plane of the orbit and the reference plane.\n        // 80-100 is a polar orbit.\n        inclination: Random.number(0, 100),\n        // inclination between 0-180 degrees\n\n        // Longitude (☊).\n        longitudeAscendingNode: Random.number(0, 360),\n        // Periapsis (ω): the angle measured along the orbit from the ascending node to\n        // the periapsis.\n        argumentPeriapsis: Random.number(0, 360),\n        // the angle measured along the orbital path from the periapsis to the satellite's\n        // current position, measured at a specific reference time known as the epoch.\n        // It describes the satellite's position along its orbit at a particular point in time.\n        trueAnomalyAtEpoch: Random.number(0, 360)\n      };\n\n      // Other properties (random values for demonstration)\n      const material = \"Metal\";\n      const mass = Random.number(1.0, 300.0); // random value\n      const diameter = Random.number(0.1, 1); // random value\n      const drag = Random.number(1.0, 2.2); // random value\n\n      const materialDensity = MATERIAL_DENSITY_MAP[material];\n      const density = Random.number(materialDensity - 100, materialDensity + 100); // random value\n\n      // Using volume of a sphere for rough estimate.\n      const volume = 4 / 3 * Math.PI * Math.pow(diameter / 2, 3); // random value\n\n      // Derive ballistic coefficient using the density-based formula.\n      const ballisticCoefficient = 0.5 * density * diameter * drag;\n      this.specs = {\n        material,\n        mass,\n        diameter,\n        drag,\n        density,\n        volume,\n        ballisticCoefficient\n      };\n    }\n\n    // Set mean motion at random.\n    // Initial speed (scalar) should be anywhere from 6-9 km/s.\n    // const initialSpeed = Random.number(6000, 9000); // In m/s.\n    // // Convert this to approximate (non-elliptical) revolutions per day.\n    // const circumference = 46357.341; // 2pi * 7378 (mean LEO).\n    // const dayDistanceTraveled = initialSpeed * 86400; // Seconds in a day.\n    // this.motion = dayDistanceTraveled / circumference;\n\n    if (args && args.scene) {\n      this.initThreeJSMesh(args.scene);\n    }\n  }\n\n  /**\n   * Proceed to the next animation frame. Reposition the\n   * @param timestamp Time in seconds since init. It's assumed that we init at 0.\n   */\n  step(timestamp, shouldMove = true, canInterpolate = true) {\n    if (this.path) {\n      return this.updatePositionFromFlightPath(0, PARITY, timestamp, canInterpolate);\n    } else {\n      // TODO: Move to constants!\n      // Logic to calculate new position based on timestamp.\n      const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2.\n      const earthMass = 5.972e24; // Earth mass in kg.\n\n      // Convert timestamp to seconds.\n      const t = timestamp / 1000;\n\n      // Validate input values: semiMajorAxis should be positive, eccentricity should be between 0 and 1.\n      if (this.orbit.semiMajorAxis <= 0 || this.orbit.eccentricity < 0 || this.orbit.eccentricity >= 1) {\n        console.error(\"Invalid input values for semiMajorAxis or eccentricity.\", this.orbit.semiMajorAxis, this.orbit.eccentricity);\n        return false; // Exit function early to prevent further calculations with invalid inputs.\n      }\n\n      // Calculate mean anomaly (M) based on Kepler's equation.\n      const n = Math.sqrt(G * earthMass / Math.pow(this.orbit.semiMajorAxis * 1000, 3)); // Mean motion.\n      let meanAnomaly = this.orbit.trueAnomalyAtEpoch - n * t;\n\n      // Iteratively solve Kepler's equation for eccentric anomaly (E).\n      let eccentricAnomaly = meanAnomaly; // Initial guess for eccentric anomaly.\n      let delta = 1;\n      const tolerance = 1e-10; // Tolerance for convergence.\n      while (Math.abs(delta) > tolerance) {\n        const f = eccentricAnomaly - this.orbit.eccentricity * Math.sin(eccentricAnomaly) - meanAnomaly;\n        const fPrime = 1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly);\n        delta = f / fPrime;\n        eccentricAnomaly -= delta;\n      }\n\n      // console.log(\"stuff 1\", meanAnomaly, eccentricAnomaly, delta);\n\n      // Calculate true anomaly (ν) from eccentric anomaly (E).\n      const trueAnomaly = 2 * Math.atan(Math.sqrt((1 + this.orbit.eccentricity) / (1 - this.orbit.eccentricity)) * Math.tan(eccentricAnomaly / 2));\n\n      // Calculate distance from center of the Earth to the satellite (r) using vis-viva equation.\n      const radius = this.orbit.semiMajorAxis * (1 - this.orbit.eccentricity * this.orbit.eccentricity) / (1 + this.orbit.eccentricity * Math.cos(trueAnomaly));\n\n      // Calculate position in orbital plane (x', y').\n      const xPrime = radius * Math.cos(trueAnomaly);\n      const yPrime = radius * Math.sin(trueAnomaly);\n\n      // console.log(trueAnomaly, radius, xPrime, yPrime);\n\n      // // Calculate true anomaly (ν) from eccentric anomaly (E).\n      // const cosTrueAnomaly =\n      //   (Math.cos(eccentricAnomaly) - this.orbit.eccentricity) /\n      //   (1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly));\n      // const sinTrueAnomaly =\n      //   (Math.sqrt(1 - this.orbit.eccentricity * this.orbit.eccentricity) *\n      //     Math.sin(eccentricAnomaly)) /\n      //   (1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly));\n      // const trueAnomaly = Math.atan2(sinTrueAnomaly, cosTrueAnomaly);\n\n      // // Calculate distance from center of the Earth to the satellite (r) using vis-viva equation.\n      // const radius =\n      //   (this.orbit.semiMajorAxis *\n      //     1000 *\n      //     (1 - this.orbit.eccentricity * this.orbit.eccentricity)) /\n      //   (1 + this.orbit.eccentricity * Math.cos(trueAnomaly));\n\n      // // Calculate position in orbital plane (x', y').\n      // const xPrime = radius * Math.cos(trueAnomaly);\n      // const yPrime = radius * Math.sin(trueAnomaly);\n\n      // Rotate position to align with orbital elements.\n      const cosLongitudeAscendingNode = Math.cos(this.orbit.longitudeAscendingNode);\n      const sinLongitudeAscendingNode = Math.sin(this.orbit.longitudeAscendingNode);\n      const cosArgumentPeriapsis = Math.cos(this.orbit.argumentPeriapsis);\n      const sinArgumentPeriapsis = Math.sin(this.orbit.argumentPeriapsis);\n      const cosInclination = Math.cos(this.orbit.inclination);\n      const sinInclination = Math.sin(this.orbit.inclination);\n      const x = xPrime * (cosLongitudeAscendingNode * cosArgumentPeriapsis - sinLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination) - yPrime * (sinLongitudeAscendingNode * cosArgumentPeriapsis + cosLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination);\n      const y = xPrime * (cosLongitudeAscendingNode * sinArgumentPeriapsis + sinLongitudeAscendingNode * cosArgumentPeriapsis * cosInclination) + yPrime * (cosLongitudeAscendingNode * cosArgumentPeriapsis - sinLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination);\n      const z = xPrime * (sinLongitudeAscendingNode * sinInclination) + yPrime * (cosLongitudeAscendingNode * sinInclination);\n\n      // Update object position.\n      this.position = {\n        x,\n        y,\n        z\n      };\n      if (this.mesh) {\n        // Finally, convert to three.js coordinate space and update the mesh's\n        // position.\n        const threePosition = this.toThreeJSPosition();\n        if (this.shouldLog) {\n          console.log(\"New position for mmod:\", this.position.x, this.position.y, this.position.z, threePosition.x, threePosition.y, threePosition.z);\n        }\n        if (shouldMove) {\n          this.mesh.position.set(threePosition.x, threePosition.y, threePosition.z);\n          this.mesh.updateMatrix();\n        }\n      }\n    }\n    return true;\n  }\n\n  // TODO: Maybe not needed?\n  // Timestamp should be num in ms.\n  stepMesh(args) {\n    if (!this.mesh) {\n      console.warn(\"`stepMesh` was called with no mesh instiantiated.\");\n      return false;\n    }\n    const {\n      newPos,\n      timestamp\n    } = args;\n    if (newPos) {\n      this.mesh.position.set(newPos.x, newPos.y, newPos.z);\n    } else {\n      if (!this.path) {\n        throw new Error(\"stepMesh error: New position must be provided if no flight path given.\");\n      }\n      const res = this.updatePositionFromFlightPath(0, PARITY, timestamp);\n      if (!res) {\n        // Flight path is over, no need to update matrix.\n        return false;\n      }\n    }\n    this.mesh.updateMatrix();\n    return true;\n  }\n  updatePositionFromFlightPath(startTime, parity, currentTime, canInterpolate = true) {\n    if (!this.path) {\n      throw new Error(\"updatePositionFromFlightPath error: Cannot update if no flight path provided.\");\n    }\n    if (currentTime < startTime) {\n      throw new Error(\"updatePositionFromFlightPath error: Current time must be after the start timestamp.\");\n    }\n\n    // First, find the index of the points we'll be interpolating.\n    const index = Math.floor((currentTime - startTime) / parity);\n    if (index < 0 || index >= this.path.length - 1) {\n      // This usually happens if the flight path is over.\n      // TODO: Fn to reset at beginning of path.\n      console.log(\"Current time is not between any two points' timestamps.\");\n      return false;\n    }\n    let newPos;\n    if (canInterpolate) {\n      newPos = Interpolate.linear({\n        ...this.path[index],\n        t: startTime + index * parity\n      }, {\n        ...this.path[index + 1],\n        t: startTime + (index + 1) * parity\n      }, currentTime);\n    } else {\n      newPos = this.path[index];\n    }\n    this.position = {\n      x: newPos.x,\n      y: newPos.y,\n      z: newPos.z\n    };\n    if (this.mesh) {\n      this.mesh.position.set(newPos.x, newPos.y, newPos.z);\n    }\n    return true;\n  }\n  tle(timestamp) {\n    // Line 1\n    const firstDerivativeMeanMotion = this.getFirstDerivativeMeanMotion();\n    const secondDerivativeMeanMotion = this.getSecondDerivativeMeanMotion();\n    const BSTARDragTerm = this.getBSTARDragTerm();\n    const line1 = `1 ${this.catalogNumber}U 00000A ${timestamp.toISOString().slice(2, 10).replace(/-/g, \"\")} .${firstDerivativeMeanMotion.toString().replace(/-/g, \" \").padStart(8, \" \")}${secondDerivativeMeanMotion > 0 ? secondDerivativeMeanMotion.toFixed(8).padStart(8, \" \") : \"  .00000000\"}-${BSTARDragTerm.toFixed(4).replace(/-/g, \" \").padStart(6, \" \")} 0`;\n\n    // Line 2\n    const line2 = `2 ${this.catalogNumber} ${this.orbit.inclination.toFixed(4).padStart(8, \" \")}${this.orbit.longitudeAscendingNode.toFixed(4).padStart(8, \" \")}${(this.orbit.eccentricity * 1e7).toFixed(7).replace(/\\.?0+$/, \"\").padStart(7, \" \")}${this.orbit.argumentPeriapsis.toFixed(4).padStart(8, \" \")}${this.getMeanAnomaly(timestamp.getUTCMilliseconds()).toFixed(4).padStart(8, \" \")}${this.getMeanMotion(this.orbit.semiMajorAxis, MU_EARTH).toFixed(11).replace(\".\", \"\")}`;\n    return [line1, line2];\n  }\n\n  // Function to convert position to three.js coordinates\n  toThreeJSPosition() {\n    // Scaling down the position to fit with three.js coordinates (assuming earth sphere radius is 16)\n    const scaleFactor = 20 / 6371; // TODO: Should be constants!\n    return {\n      x: this.position.x * scaleFactor,\n      y: this.position.y * scaleFactor,\n      z: this.position.z * scaleFactor\n    };\n  }\n  initThreeJSMesh(scene) {\n    if (this.mesh) {\n      console.warn(\"Mesh already exists for object. Reinitializing.\");\n      // TODO: Remove the previous mesh from the scene (assuming it's in this scene).\n    }\n    const geometry = new THREE.SphereGeometry(5, 4, 4);\n    const material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color().setHSL(0.9, 0.9, 0.9, THREE.SRGBColorSpace),\n      side: THREE.DoubleSide,\n      alphaToCoverage: true\n    });\n    this.mesh = new THREE.Mesh(geometry, material);\n    scene.add(this.mesh);\n\n    // Determine the initial position of the MMOD at random.\n    // Points on the surface of a sphere can be expressed using two\n    // spherical coordinates, theta and phi with 0 < theta < 2pi and\n    // 0 < phi < pi.\n    // Generate random values for theta and phi.\n    // const theta = Random.number(0.01, 2 * Math.PI);\n    // const phi = Math.acos(Random.number(-1, 1));\n    // TODO: Vary the radius slightly.\n    // Convert theta and phi into cartesian coordinates for the mesh.\n    // The LEO radius will be varied slightly by a modifier, targeting\n    // anywhere from 1000 km to 2000 km above the surface of the earth.\n    const threePosition = this.toThreeJSPosition();\n    this.mesh.position.x = threePosition.x; //LEO_RADIUS * Math.cos(theta) * Math.sin(phi);\n    this.mesh.position.y = threePosition.y; //LEO_RADIUS * Math.sin(theta) * Math.sin(phi);\n    this.mesh.position.z = threePosition.z; //LEO_RADIUS * Math.cos(phi);\n    this.mesh.scale.x = this.mesh.scale.y = this.mesh.scale.z = MMOD_SCALE;\n  }\n  getMeanMotion(a, mu) {\n    // Semi-major axis 'a' in meters\n    // Gravitational parameter 'mu' in m^3/s^2\n\n    // Calculate mean motion (n)\n    const n = Math.sqrt(mu / Math.pow(a, 3));\n\n    // Convert mean motion to revolutions per day\n    const meanMotionRevPerDay = n * (86400 / (2 * Math.PI));\n    return meanMotionRevPerDay;\n  }\n  getFirstDerivativeMeanMotion() {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Calculate the semi-major axis of the orbit in meters\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n\n    // Calculate the mean motion (n) in radians per second\n    const meanMotion = Math.sqrt(G * earthMass / Math.pow(semiMajorAxisMeters, 3));\n\n    // Return the first derivative of mean motion\n    return -1.5 * meanMotion * this.orbit.eccentricity ** 2;\n  }\n\n  // Function to calculate the second derivative of mean motion\n  getSecondDerivativeMeanMotion() {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Calculate the semi-major axis of the orbit in meters\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n\n    // Calculate the mean motion (n) in radians per second\n    const meanMotion = Math.sqrt(G * earthMass / Math.pow(semiMajorAxisMeters, 3));\n\n    // Calculate the eccentricity squared\n    const eccentricitySquared = this.orbit.eccentricity * this.orbit.eccentricity;\n\n    // Return the second derivative of mean motion\n    return -meanMotion * eccentricitySquared * (4 * eccentricitySquared - 5) / semiMajorAxisMeters;\n  }\n  getBSTARDragTerm() {\n    // Constants\n    // TODO: Move to constants!\n    const earthRadius = 6371; // Earth radius in kilometers\n    // const earthMass = 5.972e24; // Earth mass in kg\n    // const dragCoefficient = 2.2; // Example drag coefficient\n\n    // Calculate the cross-sectional area of the object\n    // const crossSectionalArea = Math.PI * Math.pow(this.specs.diameter / 2, 2); // Assuming spherical object\n\n    // Calculate the atmospheric density at the object's altitude\n    const altitudeFromEarthCenter = this.getPositionMagnitude() - earthRadius;\n    const altitudeFromSurface = altitudeFromEarthCenter - this.earthRadius;\n    const density = this.getAtmosphericDensity(altitudeFromSurface); // Example call to get atmospheric density\n\n    // Calculate the BSTAR drag term\n    return -0.5 * this.specs.ballisticCoefficient * density;\n  }\n  getMeanAnomaly(timestamp) {\n    // Constants\n    // TODO: Move to constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Convert timestamp to seconds\n    const t = timestamp / 1000;\n\n    // Calculate mean motion (n) in radians per second\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n    const n = Math.sqrt(G * earthMass / Math.pow(semiMajorAxisMeters, 3));\n\n    // Calculate mean anomaly (M) based on Kepler's equation\n    const M = this.orbit.trueAnomalyAtEpoch - n * t;\n    return M;\n  }\n  getPositionMagnitude() {\n    return Math.sqrt(this.position.x * this.position.x + this.position.y * this.position.y + this.position.z * this.position.z);\n  }\n\n  // Function to estimate atmospheric density at a given altitude\n  getAtmosphericDensity(altitude) {\n    // TODO: Move to constants.\n    // Constants for US Standard Atmosphere model.\n    // NOTE: This is just for the troposphere (up to 11k km).\n    const T0 = 288.15; // Sea level temperature in Kelvin\n    const lapseRate = 0.0065; // Temperature lapse rate in Kelvin per meter\n    const R = 8.31447; // Universal gas constant in J/(mol*K)\n    const g0 = 9.80665; // Standard gravity in m/s^2\n    const M = 0.0289644; // Molar mass of dry air in kg/mol\n\n    // Calculate temperature at given altitude using lapse rate model.\n    const temperature = T0 - lapseRate * altitude;\n\n    // Calculate pressure at given altitude using hydrostatic equation.\n    const pressure = 101325 * Math.pow(1 - lapseRate * altitude / T0, g0 * M / (R * lapseRate));\n\n    // Calculate density using ideal gas law.\n    return pressure * M / (R * temperature);\n  }\n}","map":{"version":3,"names":["THREE","MMOD_SCALE","Random","Interpolate","MATERIAL_DENSITY_MAP","Metal","Plastic","Composite","MU_EARTH","PARITY","MMOD","constructor","args","mesh","position","catalogNumber","revolution","classification","orbit","specs","path","earthRadius","shouldLog","flight","x","y","z","altitude","number","longitude","latitude","Math","random","cos","sin","semiMajorAxis","eccentricity","inclination","longitudeAscendingNode","argumentPeriapsis","trueAnomalyAtEpoch","material","mass","diameter","drag","materialDensity","density","volume","PI","pow","ballisticCoefficient","scene","initThreeJSMesh","step","timestamp","shouldMove","canInterpolate","updatePositionFromFlightPath","G","earthMass","t","console","error","n","sqrt","meanAnomaly","eccentricAnomaly","delta","tolerance","abs","f","fPrime","trueAnomaly","atan","tan","radius","xPrime","yPrime","cosLongitudeAscendingNode","sinLongitudeAscendingNode","cosArgumentPeriapsis","sinArgumentPeriapsis","cosInclination","sinInclination","threePosition","toThreeJSPosition","log","set","updateMatrix","stepMesh","warn","newPos","Error","res","startTime","parity","currentTime","index","floor","length","linear","tle","firstDerivativeMeanMotion","getFirstDerivativeMeanMotion","secondDerivativeMeanMotion","getSecondDerivativeMeanMotion","BSTARDragTerm","getBSTARDragTerm","line1","toISOString","slice","replace","toString","padStart","toFixed","line2","getMeanAnomaly","getUTCMilliseconds","getMeanMotion","scaleFactor","geometry","SphereGeometry","MeshPhongMaterial","color","Color","setHSL","SRGBColorSpace","side","DoubleSide","alphaToCoverage","Mesh","add","scale","a","mu","meanMotionRevPerDay","semiMajorAxisMeters","meanMotion","eccentricitySquared","altitudeFromEarthCenter","getPositionMagnitude","altitudeFromSurface","getAtmosphericDensity","M","T0","lapseRate","R","g0","temperature","pressure"],"sources":["/Users/jakek/ptolemy/mmod/packages/kepler/src/scene/MMOD.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { MMOD_SCALE } from \"../helpers/Constants.ts\";\nimport { Random } from \"../helpers/Random.ts\";\nimport { Interpolate } from \"../helpers/Interpolate.ts\";\n\nexport type TLE = [string, string];\n\n// TODO: Move these to constants.\nconst MATERIAL_DENSITY_MAP: { [material: string]: number } = {\n  Metal: 7800, // Density of metal in kg/m^3\n  Plastic: 950, // Density of plastic in kg/m^3\n  Composite: 1600, // Density of composite in kg/m^3\n  // TODO: Add more materials as needed\n};\n/**\n * The gravitational parameter (μ) is a constant value for a particular\n * celestial body and represents the product of the gravitational constant (G) and the\n * mass (M) of the central body (usually a planet or a star). For Earth, μ is approximately\n * 3.986×10^14 m^3/s^2.\n */\nconst MU_EARTH = 3.986e14;\n\ntype MMODSpecs = {\n  ballisticCoefficient: number;\n  // Variables used to calculate the ballistic coefficient.\n  volume: number; // In m^3.\n  mass: number; // In kg.\n  diameter: number; // In km.\n  drag: number; // Drag coefficient of a sphere.\n  density: number; // Density of aluminum. kg/m^3\n\n  // TODO: Make into an enum.\n  material: string;\n};\n\ntype MMODOrbit = {\n  semiMajorAxis: number;\n  eccentricity: number;\n  inclination: number;\n  longitudeAscendingNode: number;\n  argumentPeriapsis: number;\n  trueAnomalyAtEpoch: number;\n};\n\n// TODO: Move to constants\nconst PARITY = 1000 * 60 * 60; // 1 hour.\n\nexport class MMOD {\n  // The three js object to be rendered.\n  public mesh: THREE.Mesh | undefined;\n\n  position: { x: number; y: number; z: number };\n\n  // TODO: Think on this one.\n  // Normally, a sequential nine-digit number assigned by the\n  // USSPACECOM in order of launch or discovery.\n  public catalogNumber = 0;\n\n  // Keplerian orbital elements, plus some others used in\n  // producing the TLE representation.\n  // See: https://en.wikipedia.org/wiki/Orbital_elements\n  // Semi-major axis is the sum of the periapsis and apoapsis\n  // distances divided by two.\n  // public semiMajorAxis: number;\n  // Inclination is the vertical tilt of the ellipse with\n  // respect to the reference plane.\n  // public inclination: number;\n  // The right ascension of the ascending node is the angle\n  // from a specified reference direction, called the origin\n  // of longitude, to the direction of the ascending node.\n  // public longitude: number;\n  // Eccentricity represents the shape of the orbital ellipse,\n  // describing how much it is elongated compared to a circle.\n  // public eccentricity: number;\n  // The argument of perigee is, parametrically, the angle\n  // from the body's ascending node to its periapsis, measured\n  // in the direction of motion.\n  // public perigee: number;\n  // Mean motion is revolutions per day.\n  // public motion: number;\n  // Mean anomaly is the fraction of an elliptical orbit's\n  // period that has elapsed since the orbiting body passed\n  // periapsis.\n  // public anomaly: number;\n  // TODO: Again, think on this. Could be prohibitive, but\n  // maybe we can exclude from target consensus data model?\n  // Revolution number (typically at a given epoch) is just\n  // a counter, again normally tracked by\n  // This will not be tracked here.\n  public revolution = 1;\n  // Will leave this at unclassified for now.\n  public classification: \"U\" | \"C\" | \"S\" = \"U\";\n\n  // TODO: Comment this\n  public orbit: MMODOrbit;\n\n  public specs: MMODSpecs;\n\n  public path: { x: number; y: number; z: number }[] | undefined;\n\n  // TODO: Move to constants.\n  // Constants\n  earthRadius: number = 6371; // in km\n\n  shouldLog = false;\n\n  /**\n   * A small point object representing orbiting debris.\n   */\n  constructor(args?: {\n    scene?: THREE.Scene;\n    flight?: {\n      path: { x: number; y: number; z: number }[];\n      specs: MMODSpecs;\n      orbit: MMODOrbit;\n    };\n  }) {\n    // TODO: test remove\n    // if (COUNT === 0) {\n    //   this.shouldLog = true;\n    // }\n    // COUNT++;\n\n    if (args && args.flight) {\n      this.orbit = args.flight.orbit;\n      this.specs = args.flight.specs;\n      this.position = {\n        x: args.flight.path[0].x,\n        y: args.flight.path[0].y,\n        z: args.flight.path[0].z,\n      };\n      this.path = args.flight.path;\n    } else {\n      // Generate random position in low earth orbit\n      const altitude = Random.number(700, 2000); // altitude between 700-2000 km\n      const longitude = Random.number(0, 360); // random longitude\n      const latitude = Math.random() * 180 - 90; // random latitude\n\n      // Convert spherical coordinates to Cartesian coordinates\n      const x =\n        (this.earthRadius + altitude) *\n        Math.cos(latitude) *\n        Math.cos(longitude);\n      const y =\n        (this.earthRadius + altitude) *\n        Math.cos(latitude) *\n        Math.sin(longitude);\n      const z = (this.earthRadius + altitude) * Math.sin(latitude);\n\n      this.position = { x, y, z };\n\n      // Generate random elliptical orbit path\n      this.orbit = {\n        semiMajorAxis: Random.number(700, 2000), // semi-major axis between 1300-2000 km\n        eccentricity: Random.number(0, 0.1),\n\n        // TODO: I think more common around 80-100..?\n        // Inclination between the plane of the orbit and the reference plane.\n        // 80-100 is a polar orbit.\n        inclination: Random.number(0, 100), // inclination between 0-180 degrees\n\n        // Longitude (☊).\n        longitudeAscendingNode: Random.number(0, 360),\n        // Periapsis (ω): the angle measured along the orbit from the ascending node to\n        // the periapsis.\n        argumentPeriapsis: Random.number(0, 360),\n        // the angle measured along the orbital path from the periapsis to the satellite's\n        // current position, measured at a specific reference time known as the epoch.\n        // It describes the satellite's position along its orbit at a particular point in time.\n        trueAnomalyAtEpoch: Random.number(0, 360),\n      };\n\n      // Other properties (random values for demonstration)\n      const material = \"Metal\";\n      const mass = Random.number(1.0, 300.0); // random value\n      const diameter = Random.number(0.1, 1); // random value\n      const drag = Random.number(1.0, 2.2); // random value\n\n      const materialDensity = MATERIAL_DENSITY_MAP[material];\n      const density = Random.number(\n        materialDensity - 100,\n        materialDensity + 100\n      ); // random value\n\n      // Using volume of a sphere for rough estimate.\n      const volume = (4 / 3) * Math.PI * Math.pow(diameter / 2, 3); // random value\n\n      // Derive ballistic coefficient using the density-based formula.\n      const ballisticCoefficient = 0.5 * density * diameter * drag;\n\n      this.specs = {\n        material,\n        mass,\n        diameter,\n        drag,\n        density,\n        volume,\n        ballisticCoefficient,\n      };\n    }\n\n    // Set mean motion at random.\n    // Initial speed (scalar) should be anywhere from 6-9 km/s.\n    // const initialSpeed = Random.number(6000, 9000); // In m/s.\n    // // Convert this to approximate (non-elliptical) revolutions per day.\n    // const circumference = 46357.341; // 2pi * 7378 (mean LEO).\n    // const dayDistanceTraveled = initialSpeed * 86400; // Seconds in a day.\n    // this.motion = dayDistanceTraveled / circumference;\n\n    if (args && args.scene) {\n      this.initThreeJSMesh(args.scene);\n    }\n  }\n\n  /**\n   * Proceed to the next animation frame. Reposition the\n   * @param timestamp Time in seconds since init. It's assumed that we init at 0.\n   */\n  public step(\n    timestamp: number,\n    shouldMove = true,\n    canInterpolate = true\n  ): boolean {\n    if (this.path) {\n      return this.updatePositionFromFlightPath(\n        0,\n        PARITY,\n        timestamp,\n        canInterpolate\n      );\n    } else {\n      // TODO: Move to constants!\n      // Logic to calculate new position based on timestamp.\n      const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2.\n      const earthMass = 5.972e24; // Earth mass in kg.\n\n      // Convert timestamp to seconds.\n      const t = timestamp / 1000;\n\n      // Validate input values: semiMajorAxis should be positive, eccentricity should be between 0 and 1.\n      if (\n        this.orbit.semiMajorAxis <= 0 ||\n        this.orbit.eccentricity < 0 ||\n        this.orbit.eccentricity >= 1\n      ) {\n        console.error(\n          \"Invalid input values for semiMajorAxis or eccentricity.\",\n          this.orbit.semiMajorAxis,\n          this.orbit.eccentricity\n        );\n        return false; // Exit function early to prevent further calculations with invalid inputs.\n      }\n\n      // Calculate mean anomaly (M) based on Kepler's equation.\n      const n = Math.sqrt(\n        (G * earthMass) / Math.pow(this.orbit.semiMajorAxis * 1000, 3)\n      ); // Mean motion.\n      let meanAnomaly = this.orbit.trueAnomalyAtEpoch - n * t;\n\n      // Iteratively solve Kepler's equation for eccentric anomaly (E).\n      let eccentricAnomaly = meanAnomaly; // Initial guess for eccentric anomaly.\n      let delta = 1;\n      const tolerance = 1e-10; // Tolerance for convergence.\n      while (Math.abs(delta) > tolerance) {\n        const f =\n          eccentricAnomaly -\n          this.orbit.eccentricity * Math.sin(eccentricAnomaly) -\n          meanAnomaly;\n        const fPrime = 1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly);\n        delta = f / fPrime;\n        eccentricAnomaly -= delta;\n      }\n\n      // console.log(\"stuff 1\", meanAnomaly, eccentricAnomaly, delta);\n\n      // Calculate true anomaly (ν) from eccentric anomaly (E).\n      const trueAnomaly =\n        2 *\n        Math.atan(\n          Math.sqrt(\n            (1 + this.orbit.eccentricity) / (1 - this.orbit.eccentricity)\n          ) * Math.tan(eccentricAnomaly / 2)\n        );\n\n      // Calculate distance from center of the Earth to the satellite (r) using vis-viva equation.\n      const radius =\n        (this.orbit.semiMajorAxis *\n          (1 - this.orbit.eccentricity * this.orbit.eccentricity)) /\n        (1 + this.orbit.eccentricity * Math.cos(trueAnomaly));\n\n      // Calculate position in orbital plane (x', y').\n      const xPrime = radius * Math.cos(trueAnomaly);\n      const yPrime = radius * Math.sin(trueAnomaly);\n\n      // console.log(trueAnomaly, radius, xPrime, yPrime);\n\n      // // Calculate true anomaly (ν) from eccentric anomaly (E).\n      // const cosTrueAnomaly =\n      //   (Math.cos(eccentricAnomaly) - this.orbit.eccentricity) /\n      //   (1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly));\n      // const sinTrueAnomaly =\n      //   (Math.sqrt(1 - this.orbit.eccentricity * this.orbit.eccentricity) *\n      //     Math.sin(eccentricAnomaly)) /\n      //   (1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly));\n      // const trueAnomaly = Math.atan2(sinTrueAnomaly, cosTrueAnomaly);\n\n      // // Calculate distance from center of the Earth to the satellite (r) using vis-viva equation.\n      // const radius =\n      //   (this.orbit.semiMajorAxis *\n      //     1000 *\n      //     (1 - this.orbit.eccentricity * this.orbit.eccentricity)) /\n      //   (1 + this.orbit.eccentricity * Math.cos(trueAnomaly));\n\n      // // Calculate position in orbital plane (x', y').\n      // const xPrime = radius * Math.cos(trueAnomaly);\n      // const yPrime = radius * Math.sin(trueAnomaly);\n\n      // Rotate position to align with orbital elements.\n      const cosLongitudeAscendingNode = Math.cos(\n        this.orbit.longitudeAscendingNode\n      );\n      const sinLongitudeAscendingNode = Math.sin(\n        this.orbit.longitudeAscendingNode\n      );\n      const cosArgumentPeriapsis = Math.cos(this.orbit.argumentPeriapsis);\n      const sinArgumentPeriapsis = Math.sin(this.orbit.argumentPeriapsis);\n      const cosInclination = Math.cos(this.orbit.inclination);\n      const sinInclination = Math.sin(this.orbit.inclination);\n\n      const x =\n        xPrime *\n          (cosLongitudeAscendingNode * cosArgumentPeriapsis -\n            sinLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination) -\n        yPrime *\n          (sinLongitudeAscendingNode * cosArgumentPeriapsis +\n            cosLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination);\n      const y =\n        xPrime *\n          (cosLongitudeAscendingNode * sinArgumentPeriapsis +\n            sinLongitudeAscendingNode * cosArgumentPeriapsis * cosInclination) +\n        yPrime *\n          (cosLongitudeAscendingNode * cosArgumentPeriapsis -\n            sinLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination);\n      const z =\n        xPrime * (sinLongitudeAscendingNode * sinInclination) +\n        yPrime * (cosLongitudeAscendingNode * sinInclination);\n\n      // Update object position.\n      this.position = { x, y, z };\n\n      if (this.mesh) {\n        // Finally, convert to three.js coordinate space and update the mesh's\n        // position.\n        const threePosition = this.toThreeJSPosition();\n\n        if (this.shouldLog) {\n          console.log(\n            \"New position for mmod:\",\n            this.position.x,\n            this.position.y,\n            this.position.z,\n            threePosition.x,\n            threePosition.y,\n            threePosition.z\n          );\n        }\n\n        if (shouldMove) {\n          this.mesh.position.set(\n            threePosition.x,\n            threePosition.y,\n            threePosition.z\n          );\n          this.mesh.updateMatrix();\n        }\n      }\n    }\n\n    return true;\n  }\n\n  // TODO: Maybe not needed?\n  // Timestamp should be num in ms.\n  public stepMesh(args: {\n    newPos?: { x: number; y: number; z: number };\n    timestamp: number;\n  }): boolean {\n    if (!this.mesh) {\n      console.warn(\"`stepMesh` was called with no mesh instiantiated.\");\n      return false;\n    }\n\n    const { newPos, timestamp } = args;\n\n    if (newPos) {\n      this.mesh.position.set(newPos.x, newPos.y, newPos.z);\n    } else {\n      if (!this.path) {\n        throw new Error(\n          \"stepMesh error: New position must be provided if no flight path given.\"\n        );\n      }\n      const res = this.updatePositionFromFlightPath(0, PARITY, timestamp);\n      if (!res) {\n        // Flight path is over, no need to update matrix.\n        return false;\n      }\n    }\n\n    this.mesh.updateMatrix();\n    return true;\n  }\n\n  private updatePositionFromFlightPath(\n    startTime: number,\n    parity: number,\n    currentTime: number,\n    canInterpolate = true\n  ): boolean {\n    if (!this.path) {\n      throw new Error(\n        \"updatePositionFromFlightPath error: Cannot update if no flight path provided.\"\n      );\n    }\n    if (currentTime < startTime) {\n      throw new Error(\n        \"updatePositionFromFlightPath error: Current time must be after the start timestamp.\"\n      );\n    }\n\n    // First, find the index of the points we'll be interpolating.\n    const index = Math.floor((currentTime - startTime) / parity);\n    if (index < 0 || index >= this.path.length - 1) {\n      // This usually happens if the flight path is over.\n      // TODO: Fn to reset at beginning of path.\n      console.log(\"Current time is not between any two points' timestamps.\");\n      return false;\n    }\n\n    let newPos: { x: number; y: number; z: number };\n    if (canInterpolate) {\n      newPos = Interpolate.linear(\n        { ...this.path[index], t: startTime + index * parity },\n        { ...this.path[index + 1], t: startTime + (index + 1) * parity },\n        currentTime\n      );\n    } else {\n      newPos = this.path[index];\n    }\n\n    this.position = { x: newPos.x, y: newPos.y, z: newPos.z };\n    if (this.mesh) {\n      this.mesh.position.set(newPos.x, newPos.y, newPos.z);\n    }\n\n    return true;\n  }\n\n  public tle(timestamp: Date): TLE {\n    // Line 1\n    const firstDerivativeMeanMotion = this.getFirstDerivativeMeanMotion();\n    const secondDerivativeMeanMotion = this.getSecondDerivativeMeanMotion();\n    const BSTARDragTerm = this.getBSTARDragTerm();\n    const line1 = `1 ${this.catalogNumber}U 00000A ${timestamp\n      .toISOString()\n      .slice(2, 10)\n      .replace(/-/g, \"\")} .${firstDerivativeMeanMotion\n      .toString()\n      .replace(/-/g, \" \")\n      .padStart(8, \" \")}${\n      secondDerivativeMeanMotion > 0\n        ? secondDerivativeMeanMotion.toFixed(8).padStart(8, \" \")\n        : \"  .00000000\"\n    }-${BSTARDragTerm.toFixed(4).replace(/-/g, \" \").padStart(6, \" \")} 0`;\n\n    // Line 2\n    const line2 = `2 ${this.catalogNumber} ${this.orbit.inclination\n      .toFixed(4)\n      .padStart(8, \" \")}${this.orbit.longitudeAscendingNode\n      .toFixed(4)\n      .padStart(8, \" \")}${(this.orbit.eccentricity * 1e7)\n      .toFixed(7)\n      .replace(/\\.?0+$/, \"\")\n      .padStart(7, \" \")}${this.orbit.argumentPeriapsis\n      .toFixed(4)\n      .padStart(8, \" \")}${this.getMeanAnomaly(timestamp.getUTCMilliseconds())\n      .toFixed(4)\n      .padStart(8, \" \")}${this.getMeanMotion(this.orbit.semiMajorAxis, MU_EARTH)\n      .toFixed(11)\n      .replace(\".\", \"\")}`;\n\n    return [line1, line2];\n  }\n\n  // Function to convert position to three.js coordinates\n  public toThreeJSPosition(): { x: number; y: number; z: number } {\n    // Scaling down the position to fit with three.js coordinates (assuming earth sphere radius is 16)\n    const scaleFactor = 20 / 6371; // TODO: Should be constants!\n    return {\n      x: this.position.x * scaleFactor,\n      y: this.position.y * scaleFactor,\n      z: this.position.z * scaleFactor,\n    };\n  }\n\n  public initThreeJSMesh(scene: THREE.Scene) {\n    if (this.mesh) {\n      console.warn(\"Mesh already exists for object. Reinitializing.\");\n      // TODO: Remove the previous mesh from the scene (assuming it's in this scene).\n    }\n\n    const geometry = new THREE.SphereGeometry(5, 4, 4);\n    const material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color().setHSL(0.9, 0.9, 0.9, THREE.SRGBColorSpace),\n      side: THREE.DoubleSide,\n      alphaToCoverage: true,\n    });\n    this.mesh = new THREE.Mesh(geometry, material);\n\n    scene.add(this.mesh);\n\n    // Determine the initial position of the MMOD at random.\n    // Points on the surface of a sphere can be expressed using two\n    // spherical coordinates, theta and phi with 0 < theta < 2pi and\n    // 0 < phi < pi.\n    // Generate random values for theta and phi.\n    // const theta = Random.number(0.01, 2 * Math.PI);\n    // const phi = Math.acos(Random.number(-1, 1));\n    // TODO: Vary the radius slightly.\n    // Convert theta and phi into cartesian coordinates for the mesh.\n    // The LEO radius will be varied slightly by a modifier, targeting\n    // anywhere from 1000 km to 2000 km above the surface of the earth.\n    const threePosition = this.toThreeJSPosition();\n    this.mesh.position.x = threePosition.x; //LEO_RADIUS * Math.cos(theta) * Math.sin(phi);\n    this.mesh.position.y = threePosition.y; //LEO_RADIUS * Math.sin(theta) * Math.sin(phi);\n    this.mesh.position.z = threePosition.z; //LEO_RADIUS * Math.cos(phi);\n    this.mesh.scale.x = this.mesh.scale.y = this.mesh.scale.z = MMOD_SCALE;\n  }\n\n  private getMeanMotion(a: number, mu: number): number {\n    // Semi-major axis 'a' in meters\n    // Gravitational parameter 'mu' in m^3/s^2\n\n    // Calculate mean motion (n)\n    const n = Math.sqrt(mu / Math.pow(a, 3));\n\n    // Convert mean motion to revolutions per day\n    const meanMotionRevPerDay = n * (86400 / (2 * Math.PI));\n\n    return meanMotionRevPerDay;\n  }\n\n  private getFirstDerivativeMeanMotion(): number {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Calculate the semi-major axis of the orbit in meters\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n\n    // Calculate the mean motion (n) in radians per second\n    const meanMotion = Math.sqrt(\n      (G * earthMass) / Math.pow(semiMajorAxisMeters, 3)\n    );\n\n    // Return the first derivative of mean motion\n    return -1.5 * meanMotion * this.orbit.eccentricity ** 2;\n  }\n\n  // Function to calculate the second derivative of mean motion\n  private getSecondDerivativeMeanMotion(): number {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Calculate the semi-major axis of the orbit in meters\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n\n    // Calculate the mean motion (n) in radians per second\n    const meanMotion = Math.sqrt(\n      (G * earthMass) / Math.pow(semiMajorAxisMeters, 3)\n    );\n\n    // Calculate the eccentricity squared\n    const eccentricitySquared =\n      this.orbit.eccentricity * this.orbit.eccentricity;\n\n    // Return the second derivative of mean motion\n    return (\n      (-meanMotion * eccentricitySquared * (4 * eccentricitySquared - 5)) /\n      semiMajorAxisMeters\n    );\n  }\n\n  private getBSTARDragTerm(): number {\n    // Constants\n    // TODO: Move to constants!\n    const earthRadius = 6371; // Earth radius in kilometers\n    // const earthMass = 5.972e24; // Earth mass in kg\n    // const dragCoefficient = 2.2; // Example drag coefficient\n\n    // Calculate the cross-sectional area of the object\n    // const crossSectionalArea = Math.PI * Math.pow(this.specs.diameter / 2, 2); // Assuming spherical object\n\n    // Calculate the atmospheric density at the object's altitude\n    const altitudeFromEarthCenter = this.getPositionMagnitude() - earthRadius;\n    const altitudeFromSurface = altitudeFromEarthCenter - this.earthRadius;\n    const density = this.getAtmosphericDensity(altitudeFromSurface); // Example call to get atmospheric density\n\n    // Calculate the BSTAR drag term\n    return -0.5 * this.specs.ballisticCoefficient * density;\n  }\n\n  private getMeanAnomaly(timestamp: number): number {\n    // Constants\n    // TODO: Move to constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Convert timestamp to seconds\n    const t = timestamp / 1000;\n\n    // Calculate mean motion (n) in radians per second\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n    const n = Math.sqrt((G * earthMass) / Math.pow(semiMajorAxisMeters, 3));\n\n    // Calculate mean anomaly (M) based on Kepler's equation\n    const M = this.orbit.trueAnomalyAtEpoch - n * t;\n\n    return M;\n  }\n\n  private getPositionMagnitude(): number {\n    return Math.sqrt(\n      this.position.x * this.position.x +\n        this.position.y * this.position.y +\n        this.position.z * this.position.z\n    );\n  }\n\n  // Function to estimate atmospheric density at a given altitude\n  private getAtmosphericDensity(altitude: number): number {\n    // TODO: Move to constants.\n    // Constants for US Standard Atmosphere model.\n    // NOTE: This is just for the troposphere (up to 11k km).\n    const T0 = 288.15; // Sea level temperature in Kelvin\n    const lapseRate = 0.0065; // Temperature lapse rate in Kelvin per meter\n    const R = 8.31447; // Universal gas constant in J/(mol*K)\n    const g0 = 9.80665; // Standard gravity in m/s^2\n    const M = 0.0289644; // Molar mass of dry air in kg/mol\n\n    // Calculate temperature at given altitude using lapse rate model.\n    const temperature = T0 - lapseRate * altitude;\n\n    // Calculate pressure at given altitude using hydrostatic equation.\n    const pressure =\n      101325 *\n      Math.pow(1 - (lapseRate * altitude) / T0, (g0 * M) / (R * lapseRate));\n\n    // Calculate density using ideal gas law.\n    return (pressure * M) / (R * temperature);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}