{"ast":null,"code":"import * as THREE from \"three\";\nimport { EARTH_RADIUS } from \"../helpers/Constants\";\nexport class Identifier {\n  constructor(scene) {\n    this.lightCone = void 0;\n    // Create a three.js cone\n\n    // Calculate the coordinates of the cone\n    const direction = new THREE.Vector3(1, 1, 1).normalize();\n    const height = 6;\n    const tip = direction.clone().multiplyScalar(EARTH_RADIUS);\n    const base = tip.clone().add(direction.clone().multiplyScalar(height));\n    this.lightCone = {\n      direction,\n      height,\n      tip,\n      base\n    };\n\n    // Create a cone\n    const coneGeometry = new THREE.ConeGeometry(0.5, 1, 32);\n    const coneMaterial = new THREE.MeshBasicMaterial({\n      color: 0xff0000,\n      wireframe: true\n    });\n    const cone = new THREE.Mesh(coneGeometry, coneMaterial);\n    cone.position.copy(tip);\n\n    // Calculate rotation axis and angle\n    // const rotationAxis = new THREE.Vector3()\n    //   .crossVectors(tip, base)\n    //   .normalize();\n    // const rotationAngle = Math.acos(\n    //   tip.dot(base) / (tip.length() * base.length())\n    // );\n    // Set cone's position and rotation\n    // cone.position.copy(tip);\n    // cone.rotation.setFromVector3(rotationAxis.multiplyScalar(rotationAngle));\n    // cone.rotateX(rotationAxis.x * rotationAngle);\n    // cone.rotateY(rotationAxis.y * rotationAngle);\n    // cone.rotateZ(rotationAxis.z * rotationAngle);\n\n    // Calculate rotation axis and angle\n    const rotationAxis = new THREE.Vector3().crossVectors(tip, base).normalize();\n    const rotationAngle = Math.acos(tip.dot(base) / (tip.length() * base.length()));\n\n    // Set cone's position and rotation\n    cone.position.copy(tip);\n    cone.rotateOnAxis(rotationAxis, rotationAngle);\n\n    // Add the cone to the three.js scene.\n    scene.add(cone);\n\n    // Given parameters:\n    // Radius of the sphere.\n    // const radius: number = 1.0;\n    // // Direction of the base of the cone (as a unit vector).\n    // const direction: [number, number, number] = [1, 1, 1];\n    // // Length of the cone; essentially, height.\n    // const coneLength: number = 2.0;\n\n    // // Calculate the coordinates of the tip of the cone\n    // const xt: number = direction[0] * radius;\n    // const yt: number = direction[1] * radius;\n    // const zt: number = direction[2] * radius;\n\n    // // Calculate the coordinates of the base of the cone\n    // const xb: number = xt + direction[0] * coneLength;\n    // const yb: number = yt + direction[1] * coneLength;\n    // const zb: number = zt + direction[2] * coneLength;\n\n    // // Convert Cartesian coordinates to spherical coordinates\n    // const thetaTip: number = Math.atan2(yt, xt); // Angle of the tip point in the xy plane\n    // const phiTip: number = Math.atan2(Math.sqrt(xt ** 2 + yt ** 2), zt); // Angle between the positive z-axis and the vector to the tip point\n    // const thetaBase: number = Math.atan2(yb, xb); // Angle of the base point in the xy plane\n    // const phiBase: number = Math.atan2(Math.sqrt(xb ** 2 + yb ** 2), zb); // Angle between the positive z-axis and the vector to the base point\n\n    // // Calculate thetaStart and thetaLength\n    // let thetaStart: number = Math.min(thetaTip, thetaBase);\n    // let thetaLength: number = Math.abs(thetaTip - thetaBase);\n\n    // // Ensure thetaLength is positive and in the range [0, 2*pi]\n    // if (thetaLength < 0) {\n    //   thetaLength += 2 * Math.PI;\n    // }\n\n    // // Convert thetaStart and thetaLength to degrees if needed\n    // const thetaStartDegrees: number = (thetaStart * 180) / Math.PI;\n    // const thetaLengthDegrees: number = (thetaLength * 180) / Math.PI;\n  }\n}","map":{"version":3,"names":["THREE","EARTH_RADIUS","Identifier","constructor","scene","lightCone","direction","Vector3","normalize","height","tip","clone","multiplyScalar","base","add","coneGeometry","ConeGeometry","coneMaterial","MeshBasicMaterial","color","wireframe","cone","Mesh","position","copy","rotationAxis","crossVectors","rotationAngle","Math","acos","dot","length","rotateOnAxis"],"sources":["/home/jake/ptolemy/mmod/packages/kepler/src/scene/Identifier.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { EARTH_RADIUS } from \"../helpers/Constants\";\n\nexport type VisualCone = {\n  direction: THREE.Vector3;\n  height: number;\n  tip: THREE.Vector3;\n  base: THREE.Vector3;\n};\n\nexport class Identifier {\n  public readonly lightCone: VisualCone;\n\n  constructor(scene: THREE.Scene) {\n    // Create a three.js cone\n\n    // Calculate the coordinates of the cone\n    const direction = new THREE.Vector3(1, 1, 1).normalize();\n    const height = 6;\n    const tip = direction.clone().multiplyScalar(EARTH_RADIUS);\n    const base = tip.clone().add(direction.clone().multiplyScalar(height));\n    this.lightCone = {\n      direction,\n      height,\n      tip,\n      base,\n    };\n\n    // Create a cone\n    const coneGeometry = new THREE.ConeGeometry(0.5, 1, 32);\n    const coneMaterial = new THREE.MeshBasicMaterial({\n      color: 0xff0000,\n      wireframe: true,\n    });\n    const cone = new THREE.Mesh(coneGeometry, coneMaterial);\n    cone.position.copy(tip);\n\n    // Calculate rotation axis and angle\n    // const rotationAxis = new THREE.Vector3()\n    //   .crossVectors(tip, base)\n    //   .normalize();\n    // const rotationAngle = Math.acos(\n    //   tip.dot(base) / (tip.length() * base.length())\n    // );\n    // Set cone's position and rotation\n    // cone.position.copy(tip);\n    // cone.rotation.setFromVector3(rotationAxis.multiplyScalar(rotationAngle));\n    // cone.rotateX(rotationAxis.x * rotationAngle);\n    // cone.rotateY(rotationAxis.y * rotationAngle);\n    // cone.rotateZ(rotationAxis.z * rotationAngle);\n\n    // Calculate rotation axis and angle\n    const rotationAxis = new THREE.Vector3()\n      .crossVectors(tip, base)\n      .normalize();\n    const rotationAngle = Math.acos(\n      tip.dot(base) / (tip.length() * base.length())\n    );\n\n    // Set cone's position and rotation\n    cone.position.copy(tip);\n    cone.rotateOnAxis(rotationAxis, rotationAngle);\n\n    // Add the cone to the three.js scene.\n    scene.add(cone);\n\n    // Given parameters:\n    // Radius of the sphere.\n    // const radius: number = 1.0;\n    // // Direction of the base of the cone (as a unit vector).\n    // const direction: [number, number, number] = [1, 1, 1];\n    // // Length of the cone; essentially, height.\n    // const coneLength: number = 2.0;\n\n    // // Calculate the coordinates of the tip of the cone\n    // const xt: number = direction[0] * radius;\n    // const yt: number = direction[1] * radius;\n    // const zt: number = direction[2] * radius;\n\n    // // Calculate the coordinates of the base of the cone\n    // const xb: number = xt + direction[0] * coneLength;\n    // const yb: number = yt + direction[1] * coneLength;\n    // const zb: number = zt + direction[2] * coneLength;\n\n    // // Convert Cartesian coordinates to spherical coordinates\n    // const thetaTip: number = Math.atan2(yt, xt); // Angle of the tip point in the xy plane\n    // const phiTip: number = Math.atan2(Math.sqrt(xt ** 2 + yt ** 2), zt); // Angle between the positive z-axis and the vector to the tip point\n    // const thetaBase: number = Math.atan2(yb, xb); // Angle of the base point in the xy plane\n    // const phiBase: number = Math.atan2(Math.sqrt(xb ** 2 + yb ** 2), zb); // Angle between the positive z-axis and the vector to the base point\n\n    // // Calculate thetaStart and thetaLength\n    // let thetaStart: number = Math.min(thetaTip, thetaBase);\n    // let thetaLength: number = Math.abs(thetaTip - thetaBase);\n\n    // // Ensure thetaLength is positive and in the range [0, 2*pi]\n    // if (thetaLength < 0) {\n    //   thetaLength += 2 * Math.PI;\n    // }\n\n    // // Convert thetaStart and thetaLength to degrees if needed\n    // const thetaStartDegrees: number = (thetaStart * 180) / Math.PI;\n    // const thetaLengthDegrees: number = (thetaLength * 180) / Math.PI;\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,YAAY,QAAQ,sBAAsB;AASnD,OAAO,MAAMC,UAAU,CAAC;EAGtBC,WAAWA,CAACC,KAAkB,EAAE;IAAA,KAFhBC,SAAS;IAGvB;;IAEA;IACA,MAAMC,SAAS,GAAG,IAAIN,KAAK,CAACO,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAACC,SAAS,CAAC,CAAC;IACxD,MAAMC,MAAM,GAAG,CAAC;IAChB,MAAMC,GAAG,GAAGJ,SAAS,CAACK,KAAK,CAAC,CAAC,CAACC,cAAc,CAACX,YAAY,CAAC;IAC1D,MAAMY,IAAI,GAAGH,GAAG,CAACC,KAAK,CAAC,CAAC,CAACG,GAAG,CAACR,SAAS,CAACK,KAAK,CAAC,CAAC,CAACC,cAAc,CAACH,MAAM,CAAC,CAAC;IACtE,IAAI,CAACJ,SAAS,GAAG;MACfC,SAAS;MACTG,MAAM;MACNC,GAAG;MACHG;IACF,CAAC;;IAED;IACA,MAAME,YAAY,GAAG,IAAIf,KAAK,CAACgB,YAAY,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,CAAC;IACvD,MAAMC,YAAY,GAAG,IAAIjB,KAAK,CAACkB,iBAAiB,CAAC;MAC/CC,KAAK,EAAE,QAAQ;MACfC,SAAS,EAAE;IACb,CAAC,CAAC;IACF,MAAMC,IAAI,GAAG,IAAIrB,KAAK,CAACsB,IAAI,CAACP,YAAY,EAAEE,YAAY,CAAC;IACvDI,IAAI,CAACE,QAAQ,CAACC,IAAI,CAACd,GAAG,CAAC;;IAEvB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA,MAAMe,YAAY,GAAG,IAAIzB,KAAK,CAACO,OAAO,CAAC,CAAC,CACrCmB,YAAY,CAAChB,GAAG,EAAEG,IAAI,CAAC,CACvBL,SAAS,CAAC,CAAC;IACd,MAAMmB,aAAa,GAAGC,IAAI,CAACC,IAAI,CAC7BnB,GAAG,CAACoB,GAAG,CAACjB,IAAI,CAAC,IAAIH,GAAG,CAACqB,MAAM,CAAC,CAAC,GAAGlB,IAAI,CAACkB,MAAM,CAAC,CAAC,CAC/C,CAAC;;IAED;IACAV,IAAI,CAACE,QAAQ,CAACC,IAAI,CAACd,GAAG,CAAC;IACvBW,IAAI,CAACW,YAAY,CAACP,YAAY,EAAEE,aAAa,CAAC;;IAE9C;IACAvB,KAAK,CAACU,GAAG,CAACO,IAAI,CAAC;;IAEf;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;;IAEA;IACA;IACA;IACA;;IAEA;IACA;IACA;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}