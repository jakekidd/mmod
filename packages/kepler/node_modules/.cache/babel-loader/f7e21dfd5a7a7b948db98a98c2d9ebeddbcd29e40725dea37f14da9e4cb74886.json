{"ast":null,"code":"export class Aggregator {\n  example() {\n    // Example usage\n    const points = [{\n      x: 1,\n      y: 2,\n      z: 3,\n      C: 0.8\n    }, {\n      x: 1.1,\n      y: 2.1,\n      z: 3.2,\n      C: 0.6\n    }, {\n      x: 5,\n      y: 6,\n      z: 7,\n      C: 0.9\n    }, {\n      x: 1.05,\n      y: 2.05,\n      z: 3.15,\n      C: 0.7\n    }, {\n      x: 10,\n      y: 11,\n      z: 12,\n      C: 0.75\n    }];\n    const epsilon = 0.1;\n    const labeledPoints = this.labelPoints(points, epsilon);\n    const aggregatedPoints = this.aggregatePoints(labeledPoints);\n    console.log(aggregatedPoints);\n  }\n  labelPoints(points, epsilon) {\n    let labels = [];\n    let labeledPoints = [];\n    points.forEach(point => {\n      let foundLabel = false;\n      for (let i = 0; i < labeledPoints.length; i++) {\n        const labeledPoint = labeledPoints[i].points[0];\n        if (this.distance(point, labeledPoint) < epsilon) {\n          labeledPoints[i].points.push(point);\n          foundLabel = true;\n          break;\n        }\n      }\n      if (!foundLabel) {\n        const label = labels.length;\n        labels.push(label);\n        labeledPoints.push({\n          label,\n          points: [point]\n        });\n      }\n    });\n    return labeledPoints;\n  }\n  aggregatePoints(labeledPoints) {\n    let aggregatedPoints = [];\n    labeledPoints.forEach(group => {\n      let totalX = 0;\n      let totalY = 0;\n      let totalZ = 0;\n      let totalConfidence = 0;\n      let totalCorroboration = 0;\n      group.points.forEach(point => {\n        totalX += point.x;\n        totalY += point.y;\n        totalZ += point.z;\n        totalConfidence += point.C;\n        totalCorroboration++;\n      });\n      const meanX = totalX / group.points.length;\n      const meanY = totalY / group.points.length;\n      const meanZ = totalZ / group.points.length;\n      const meanConfidence = totalConfidence / group.points.length;\n      aggregatedPoints.push({\n        x: meanX,\n        y: meanY,\n        z: meanZ,\n        C: meanConfidence\n      });\n    });\n    return aggregatedPoints;\n  }\n  distance(p1, p2) {\n    return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2 + (p2.z - p1.z) ** 2);\n  }\n}","map":{"version":3,"names":["Aggregator","example","points","x","y","z","C","epsilon","labeledPoints","labelPoints","aggregatedPoints","aggregatePoints","console","log","labels","forEach","point","foundLabel","i","length","labeledPoint","distance","push","label","group","totalX","totalY","totalZ","totalConfidence","totalCorroboration","meanX","meanY","meanZ","meanConfidence","p1","p2","Math","sqrt"],"sources":["/home/jake/ptolemy/mmod/packages/kepler/src/model/Aggregator.ts"],"sourcesContent":["import { Point, LabeledPoint } from \"./Point\";\n\nexport class Aggregator {\n  public example() {\n    // Example usage\n    const points: Point[] = [\n      { x: 1, y: 2, z: 3, C: 0.8 },\n      { x: 1.1, y: 2.1, z: 3.2, C: 0.6 },\n      { x: 5, y: 6, z: 7, C: 0.9 },\n      { x: 1.05, y: 2.05, z: 3.15, C: 0.7 },\n      { x: 10, y: 11, z: 12, C: 0.75 },\n    ];\n\n    const epsilon = 0.1;\n    const labeledPoints = this.labelPoints(points, epsilon);\n    const aggregatedPoints = this.aggregatePoints(labeledPoints);\n\n    console.log(aggregatedPoints);\n  }\n\n  public labelPoints(points: Point[], epsilon: number): LabeledPoint[] {\n    let labels: number[] = [];\n    let labeledPoints: LabeledPoint[] = [];\n\n    points.forEach((point) => {\n      let foundLabel = false;\n      for (let i = 0; i < labeledPoints.length; i++) {\n        const labeledPoint = labeledPoints[i].points[0];\n        if (this.distance(point, labeledPoint) < epsilon) {\n          labeledPoints[i].points.push(point);\n          foundLabel = true;\n          break;\n        }\n      }\n      if (!foundLabel) {\n        const label = labels.length;\n        labels.push(label);\n        labeledPoints.push({ label, points: [point] });\n      }\n    });\n\n    return labeledPoints;\n  }\n\n  public aggregatePoints(labeledPoints: LabeledPoint[]): Point[] {\n    let aggregatedPoints: Point[] = [];\n\n    labeledPoints.forEach((group) => {\n      let totalX = 0;\n      let totalY = 0;\n      let totalZ = 0;\n      let totalConfidence = 0;\n      let totalCorroboration = 0;\n\n      group.points.forEach((point) => {\n        totalX += point.x;\n        totalY += point.y;\n        totalZ += point.z;\n        totalConfidence += point.C;\n        totalCorroboration++;\n      });\n\n      const meanX = totalX / group.points.length;\n      const meanY = totalY / group.points.length;\n      const meanZ = totalZ / group.points.length;\n      const meanConfidence = totalConfidence / group.points.length;\n\n      aggregatedPoints.push({\n        x: meanX,\n        y: meanY,\n        z: meanZ,\n        C: meanConfidence,\n      });\n    });\n\n    return aggregatedPoints;\n  }\n\n  private distance(p1: Point, p2: Point): number {\n    return Math.sqrt(\n      (p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2 + (p2.z - p1.z) ** 2\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}