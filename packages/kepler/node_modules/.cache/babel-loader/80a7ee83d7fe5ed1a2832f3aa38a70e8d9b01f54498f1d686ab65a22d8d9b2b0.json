{"ast":null,"code":"import * as THREE from \"three\";\nimport { LEO_RADIUS, MMOD_SCALE } from \"../helpers/Constants\";\nimport { Random } from \"../helpers/Random\";\n// TODO: Move these to constants.\nconst MATERIAL_DENSITY_MAP = {\n  Metal: 7800,\n  // Density of metal in kg/m^3\n  Plastic: 950,\n  // Density of plastic in kg/m^3\n  Composite: 1600 // Density of composite in kg/m^3\n  // TODO: Add more materials as needed\n};\n/**\n * The gravitational parameter (μ) is a constant value for a particular\n * celestial body and represents the product of the gravitational constant (G) and the\n * mass (M) of the central body (usually a planet or a star). For Earth, μ is approximately\n * 3.986×10^14 m^3/s^2.\n */\nconst MU_EARTH = 3.986e14;\nexport class MMOD {\n  // in km\n\n  /**\n   * A small point object representing orbiting debris.\n   */\n  constructor(scene) {\n    // The three js object to be rendered.\n    this.mesh = void 0;\n    this.position = void 0;\n    // TODO: Think on this one.\n    // Normally, a sequential nine-digit number assigned by the\n    // USSPACECOM in order of launch or discovery.\n    this.catalogNumber = 0;\n    // Keplerian orbital elements, plus some others used in\n    // producing the TLE representation.\n    // See: https://en.wikipedia.org/wiki/Orbital_elements\n    // Semi-major axis is the sum of the periapsis and apoapsis\n    // distances divided by two.\n    // public semiMajorAxis: number;\n    // Inclination is the vertical tilt of the ellipse with\n    // respect to the reference plane.\n    this.inclination = void 0;\n    // The right ascension of the ascending node is the angle\n    // from a specified reference direction, called the origin\n    // of longitude, to the direction of the ascending node.\n    this.longitude = void 0;\n    // Eccentricity represents the shape of the orbital ellipse,\n    // describing how much it is elongated compared to a circle.\n    this.eccentricity = void 0;\n    // The argument of perigee is, parametrically, the angle\n    // from the body's ascending node to its periapsis, measured\n    // in the direction of motion.\n    this.perigee = void 0;\n    // Mean motion is revolutions per day.\n    this.motion = void 0;\n    // Mean anomaly is the fraction of an elliptical orbit's\n    // period that has elapsed since the orbiting body passed\n    // periapsis.\n    this.anomaly = void 0;\n    // TODO: Again, think on this. Could be prohibitive, but\n    // maybe we can exclude from target consensus data model?\n    // Revolution number (typically at a given epoch) is just\n    // a counter, again normally tracked by\n    // This will not be tracked here.\n    this.revolution = 1;\n    // Will leave this at unclassified for now.\n    this.classification = \"U\";\n    // TODO: Comment this\n    this.orbit = void 0;\n    this.ballisticCoefficient = void 0;\n    // Variables used to calculate the ballistic coefficient.\n    this.volume = void 0;\n    // In m^3.\n    this.mass = void 0;\n    // In kg.\n    this.diameter = void 0;\n    // In km.\n    this.drag = 0.47;\n    // Drag coefficient of a sphere.\n    this.density = 2700.0;\n    // Density of aluminum. kg/m^3\n    // TODO: Make into an enum.\n    this.material = void 0;\n    // TODO: Move to constants.\n    // Constants\n    this.earthRadius = 6371;\n    // Generate random position in low earth orbit\n    const altitude = Math.floor(Math.random() * 1300) + 700; // altitude between 700-2000 km\n    const longitude = Math.random() * 360; // random longitude\n    const latitude = Math.random() * 180 - 90; // random latitude\n\n    // Convert spherical coordinates to Cartesian coordinates\n    const x = (this.earthRadius + altitude) * Math.cos(latitude) * Math.cos(longitude);\n    const y = (this.earthRadius + altitude) * Math.cos(latitude) * Math.sin(longitude);\n    const z = (this.earthRadius + altitude) * Math.sin(latitude);\n    this.position = {\n      x,\n      y,\n      z\n    };\n\n    // Generate random elliptical orbit path\n    this.orbit = {\n      semiMajorAxis: Random.number(700, 2000),\n      // semi-major axis between 1300-2000 km\n      eccentricity: Random.number(0, 0.5),\n      // TODO: I think more common around 80-100..?\n      // Inclination between the plane of the orbit and the reference plane.\n      // 80-100 is a polar orbit.\n      inclination: Random.number(0, 100),\n      // inclination between 0-180 degrees\n\n      // Longitude (☊).\n      longitudeAscendingNode: Random.number(0, 360),\n      // Periapsis (ω): the angle measured along the orbit from the ascending node to\n      // the periapsis.\n      argumentPeriapsis: Random.number(0, 360),\n      // the angle measured along the orbital path from the periapsis to the satellite's\n      // current position, measured at a specific reference time known as the epoch.\n      // It describes the satellite's position along its orbit at a particular point in time.\n      trueAnomalyAtEpoch: Random.number(0, 360)\n    };\n\n    // Other properties (random values for demonstration)\n    this.material = \"Metal\";\n    this.mass = Random.number(1.0, 300.0); // random value\n    this.diameter = Random.number(0.1, 1); // random value\n    this.drag = Random.number(1.0, 2.2); // random value\n\n    const materialDensity = MATERIAL_DENSITY_MAP[this.material];\n    this.density = Random.number(materialDensity - 100, materialDensity + 100); // random value\n\n    this.volume = 4 / 3 * Math.PI * Math.pow(this.diameter / 2, 3); // random value\n\n    // Derive ballistic coefficient using the density-based formula.\n    this.ballisticCoefficient = 0.5 * this.density * this.diameter * this.drag;\n    const geometry = new THREE.SphereGeometry(1, 1, 1);\n    const material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color().setHSL(0.9, 0.9, 0.9, THREE.SRGBColorSpace),\n      side: THREE.DoubleSide,\n      alphaToCoverage: true\n    });\n    this.mesh = new THREE.Mesh(geometry, material);\n\n    // Determine the initial position of the MMOD at random.\n    // Points on the surface of a sphere can be expressed using two\n    // spherical coordinates, theta and phi with 0 < theta < 2pi and\n    // 0 < phi < pi.\n    // Generate random values for theta and phi.\n    const theta = Random.number(0.01, 2 * Math.PI);\n    const phi = Math.acos(Random.number(-1, 1));\n    // TODO: Vary the radius slightly.\n    // Convert theta and phi into cartesian coordinates for the mesh.\n    // The LEO radius will be varied slightly by a modifier, targeting\n    // anywhere from 1000 km to 2000 km above the surface of the earth.\n    this.mesh.position.x = LEO_RADIUS * Math.cos(theta) * Math.sin(phi);\n    this.mesh.position.y = LEO_RADIUS * Math.sin(theta) * Math.sin(phi);\n    this.mesh.position.z = LEO_RADIUS * Math.cos(phi);\n    this.mesh.scale.x = this.mesh.scale.y = this.mesh.scale.z = MMOD_SCALE;\n\n    // Set mean motion at random.\n    // Initial speed (scalar) should be anywhere from 6-9 km/s.\n    const initialSpeed = Random.number(6000, 9000); // In m/s.\n    // Convert this to approximate (non-elliptical) revolutions per day.\n    const circumference = 46357.341; // 2pi * 7378 (mean LEO).\n    const dayDistanceTraveled = initialSpeed * 86400; // Seconds in a day.\n    this.motion = dayDistanceTraveled / circumference;\n\n    // Set inclination at random.\n    this.inclination = Random.number(40.0, 60.0);\n\n    // Set eccentricity at random.\n    this.eccentricity = Random.number(0.0, 0.0009);\n\n    // Set argument of perigee at random.\n    this.perigee = Random.number(100.0, 150.0);\n\n    // Set mean anomaly at random.\n    this.anomaly = Random.number(300.0, 350.0);\n\n    // Set longitude at random.\n    this.longitude = Random.number(200, 300);\n\n    // Set mass, diameter at random.\n    this.mass = Random.number(0.01, 0.2);\n    this.diameter = Random.number(0.0001, 0.0003);\n    scene.add(this.mesh);\n  }\n\n  /**\n   * Proceed to the next animation frame. Reposition the\n   * @param timestamp Time in seconds since init. It's assumed that we init at 0.\n   */\n  step(timestamp) {\n    // Logic to calculate new position based on timestamp.\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2.\n    const earthMass = 5.972e24; // Earth mass in kg.\n\n    // Convert timestamp to seconds.\n    const t = timestamp / 1000;\n\n    // Calculate mean anomaly (M) based on Kepler's equation.\n    const n = Math.sqrt(G * earthMass / Math.pow(this.orbit.semiMajorAxis * 1000, 3)); // Mean motion.\n    let meanAnomaly = this.orbit.trueAnomalyAtEpoch - n * t;\n\n    // Iteratively solve Kepler's equation for eccentric anomaly (E).\n    let eccentricAnomaly = meanAnomaly; // Initial guess for eccentric anomaly.\n    let delta = 1;\n    const tolerance = 1e-10; // Tolerance for convergence.\n    while (Math.abs(delta) > tolerance) {\n      const f = eccentricAnomaly - this.orbit.eccentricity * Math.sin(eccentricAnomaly) - meanAnomaly;\n      const fPrime = 1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly);\n      delta = f / fPrime;\n      eccentricAnomaly -= delta;\n    }\n\n    // Calculate true anomaly (ν) from eccentric anomaly (E).\n    const cosTrueAnomaly = (Math.cos(eccentricAnomaly) - this.orbit.eccentricity) / (1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly));\n    const sinTrueAnomaly = Math.sqrt(1 - this.orbit.eccentricity * this.orbit.eccentricity) * Math.sin(eccentricAnomaly) / (1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly));\n    const trueAnomaly = Math.atan2(sinTrueAnomaly, cosTrueAnomaly);\n\n    // Calculate distance from center of the Earth to the satellite (r) using vis-viva equation.\n    const radius = this.orbit.semiMajorAxis * 1000 * (1 - this.orbit.eccentricity * this.orbit.eccentricity) / (1 + this.orbit.eccentricity * Math.cos(trueAnomaly));\n\n    // Calculate position in orbital plane (x', y').\n    const xPrime = radius * Math.cos(trueAnomaly);\n    const yPrime = radius * Math.sin(trueAnomaly);\n\n    // Rotate position to align with orbital elements.\n    const cosLongitudeAscendingNode = Math.cos(this.orbit.longitudeAscendingNode);\n    const sinLongitudeAscendingNode = Math.sin(this.orbit.longitudeAscendingNode);\n    const cosArgumentPeriapsis = Math.cos(this.orbit.argumentPeriapsis);\n    const sinArgumentPeriapsis = Math.sin(this.orbit.argumentPeriapsis);\n    const cosInclination = Math.cos(this.orbit.inclination);\n    const sinInclination = Math.sin(this.orbit.inclination);\n    const x = xPrime * (cosLongitudeAscendingNode * cosArgumentPeriapsis - sinLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination) - yPrime * (sinLongitudeAscendingNode * cosArgumentPeriapsis + cosLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination);\n    const y = xPrime * (cosLongitudeAscendingNode * sinArgumentPeriapsis + sinLongitudeAscendingNode * cosArgumentPeriapsis * cosInclination) + yPrime * (cosLongitudeAscendingNode * cosArgumentPeriapsis - sinLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination);\n    const z = xPrime * (sinLongitudeAscendingNode * sinInclination) + yPrime * (cosLongitudeAscendingNode * sinInclination);\n\n    // Update object position.\n    this.position = {\n      x,\n      y,\n      z\n    };\n\n    // Finally, convert to three.js coordinate space and update the mesh's\n    // position.\n    const threePosition = this.toThreeJSPosition();\n    this.mesh.position.x = threePosition.x;\n    this.mesh.position.y = threePosition.y;\n    this.mesh.position.z = threePosition.z;\n  }\n  tle(timestamp) {\n    // Line 1\n    const firstDerivativeMeanMotion = this.getFirstDerivativeMeanMotion();\n    const secondDerivativeMeanMotion = this.getSecondDerivativeMeanMotion();\n    const BSTARDragTerm = this.getBSTARDragTerm();\n    const line1 = `1 ${this.catalogNumber}U 00000A ${timestamp.toISOString().slice(2, 10).replace(/-/g, \"\")} .${firstDerivativeMeanMotion.toString().replace(/-/g, \" \").padStart(8, \" \")}${secondDerivativeMeanMotion > 0 ? secondDerivativeMeanMotion.toFixed(8).padStart(8, \" \") : \"  .00000000\"}-${BSTARDragTerm.toFixed(4).replace(/-/g, \" \").padStart(6, \" \")} 0`;\n\n    // Line 2\n    const line2 = `2 ${this.catalogNumber} ${this.inclination.toFixed(4).padStart(8, \" \")}${this.orbit.longitudeAscendingNode.toFixed(4).padStart(8, \" \")}${(this.eccentricity * 1e7).toFixed(7).replace(/\\.?0+$/, \"\").padStart(7, \" \")}${this.orbit.argumentPeriapsis.toFixed(4).padStart(8, \" \")}${this.getMeanAnomaly(timestamp.getUTCMilliseconds()).toFixed(4).padStart(8, \" \")}${this.getMeanMotion(this.orbit.semiMajorAxis, MU_EARTH).toFixed(11).replace(\".\", \"\")}`;\n    return [line1, line2];\n  }\n  getMeanMotion(a, mu) {\n    // Semi-major axis 'a' in meters\n    // Gravitational parameter 'mu' in m^3/s^2\n\n    // Calculate mean motion (n)\n    const n = Math.sqrt(mu / Math.pow(a, 3));\n\n    // Convert mean motion to revolutions per day\n    const meanMotionRevPerDay = n * (86400 / (2 * Math.PI));\n    return meanMotionRevPerDay;\n  }\n  getFirstDerivativeMeanMotion() {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Calculate the semi-major axis of the orbit in meters\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n\n    // Calculate the mean motion (n) in radians per second\n    const meanMotion = Math.sqrt(G * earthMass / Math.pow(semiMajorAxisMeters, 3));\n\n    // Return the first derivative of mean motion\n    return -1.5 * meanMotion * this.orbit.eccentricity * this.orbit.eccentricity;\n  }\n\n  // Function to calculate the second derivative of mean motion\n  getSecondDerivativeMeanMotion() {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Calculate the semi-major axis of the orbit in meters\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n\n    // Calculate the mean motion (n) in radians per second\n    const meanMotion = Math.sqrt(G * earthMass / Math.pow(semiMajorAxisMeters, 3));\n\n    // Calculate the eccentricity squared\n    const eccentricitySquared = this.orbit.eccentricity * this.orbit.eccentricity;\n\n    // Return the second derivative of mean motion\n    return -meanMotion * eccentricitySquared * (4 * eccentricitySquared - 5) / semiMajorAxisMeters;\n  }\n  getBSTARDragTerm() {\n    // Constants\n    // TODO: Move to constants!\n    const earthRadius = 6371; // Earth radius in kilometers\n    const earthMass = 5.972e24; // Earth mass in kg\n    const dragCoefficient = 2.2; // Example drag coefficient\n\n    // Calculate the cross-sectional area of the object\n    const crossSectionalArea = Math.PI * Math.pow(this.diameter / 2, 2); // Assuming spherical object\n\n    // Calculate the ballistic coefficient\n    const ballisticCoefficient = dragCoefficient * (crossSectionalArea / this.mass);\n\n    // Calculate the atmospheric density at the object's altitude\n    const altitudeFromEarthCenter = this.getPositionMagnitude() - earthRadius;\n    const altitudeFromSurface = altitudeFromEarthCenter - this.earthRadius;\n    const density = this.getAtmosphericDensity(altitudeFromSurface); // Example call to get atmospheric density\n\n    // Calculate the BSTAR drag term\n    return -0.5 * ballisticCoefficient * density;\n  }\n  getMeanAnomaly(timestamp) {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Convert timestamp to seconds\n    const t = timestamp / 1000;\n\n    // Calculate mean motion (n) in radians per second\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n    const n = Math.sqrt(G * earthMass / Math.pow(semiMajorAxisMeters, 3));\n\n    // Calculate mean anomaly (M) based on Kepler's equation\n    const M = this.orbit.trueAnomalyAtEpoch - n * t;\n    return M;\n  }\n  getPositionMagnitude() {\n    return Math.sqrt(this.position.x * this.position.x + this.position.y * this.position.y + this.position.z * this.position.z);\n  }\n\n  // Function to estimate atmospheric density at a given altitude\n  getAtmosphericDensity(altitude) {\n    // Constants for US Standard Atmosphere model.\n    // NOTE: This is just for the troposphere (up to 11k km).\n    const T0 = 288.15; // Sea level temperature in Kelvin\n    const lapseRate = 0.0065; // Temperature lapse rate in Kelvin per meter\n    const R = 8.31447; // Universal gas constant in J/(mol*K)\n    const g0 = 9.80665; // Standard gravity in m/s^2\n    const M = 0.0289644; // Molar mass of dry air in kg/mol\n\n    // Calculate temperature at given altitude using lapse rate model.\n    const temperature = T0 - lapseRate * altitude;\n\n    // Calculate pressure at given altitude using hydrostatic equation.\n    const pressure = 101325 * Math.pow(1 - lapseRate * altitude / T0, g0 * M / (R * lapseRate));\n\n    // Calculate density using ideal gas law.\n    return pressure * M / (R * temperature);\n  }\n\n  // Function to convert position to three.js coordinates\n  toThreeJSPosition() {\n    // Scaling down the position to fit with three.js coordinates (assuming earth sphere radius is 16)\n    const scaleFactor = 16 / 6371; // TODO: Should be constants!\n    return {\n      x: this.position.x * scaleFactor,\n      y: this.position.y * scaleFactor,\n      z: this.position.z * scaleFactor\n    };\n  }\n}","map":{"version":3,"names":["THREE","LEO_RADIUS","MMOD_SCALE","Random","MATERIAL_DENSITY_MAP","Metal","Plastic","Composite","MU_EARTH","MMOD","constructor","scene","mesh","position","catalogNumber","inclination","longitude","eccentricity","perigee","motion","anomaly","revolution","classification","orbit","ballisticCoefficient","volume","mass","diameter","drag","density","material","earthRadius","altitude","Math","floor","random","latitude","x","cos","y","sin","z","semiMajorAxis","number","longitudeAscendingNode","argumentPeriapsis","trueAnomalyAtEpoch","materialDensity","PI","pow","geometry","SphereGeometry","MeshPhongMaterial","color","Color","setHSL","SRGBColorSpace","side","DoubleSide","alphaToCoverage","Mesh","theta","phi","acos","scale","initialSpeed","circumference","dayDistanceTraveled","add","step","timestamp","G","earthMass","t","n","sqrt","meanAnomaly","eccentricAnomaly","delta","tolerance","abs","f","fPrime","cosTrueAnomaly","sinTrueAnomaly","trueAnomaly","atan2","radius","xPrime","yPrime","cosLongitudeAscendingNode","sinLongitudeAscendingNode","cosArgumentPeriapsis","sinArgumentPeriapsis","cosInclination","sinInclination","threePosition","toThreeJSPosition","tle","firstDerivativeMeanMotion","getFirstDerivativeMeanMotion","secondDerivativeMeanMotion","getSecondDerivativeMeanMotion","BSTARDragTerm","getBSTARDragTerm","line1","toISOString","slice","replace","toString","padStart","toFixed","line2","getMeanAnomaly","getUTCMilliseconds","getMeanMotion","a","mu","meanMotionRevPerDay","semiMajorAxisMeters","meanMotion","eccentricitySquared","dragCoefficient","crossSectionalArea","altitudeFromEarthCenter","getPositionMagnitude","altitudeFromSurface","getAtmosphericDensity","M","T0","lapseRate","R","g0","temperature","pressure","scaleFactor"],"sources":["/home/jake/ptolemy/mmod/packages/kepler/src/scene/MMOD.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { LEO_RADIUS, MMOD_SCALE } from \"../helpers/Constants\";\nimport { Random } from \"../helpers/Random\";\n\nexport type TLE = [string, string];\n\n// TODO: Move these to constants.\nconst MATERIAL_DENSITY_MAP: { [material: string]: number } = {\n  Metal: 7800, // Density of metal in kg/m^3\n  Plastic: 950, // Density of plastic in kg/m^3\n  Composite: 1600, // Density of composite in kg/m^3\n  // TODO: Add more materials as needed\n};\n/**\n * The gravitational parameter (μ) is a constant value for a particular\n * celestial body and represents the product of the gravitational constant (G) and the\n * mass (M) of the central body (usually a planet or a star). For Earth, μ is approximately\n * 3.986×10^14 m^3/s^2.\n */\nconst MU_EARTH = 3.986e14;\n\nexport class MMOD {\n  // The three js object to be rendered.\n  public readonly mesh: THREE.Mesh;\n\n  position: { x: number; y: number; z: number };\n\n  // TODO: Think on this one.\n  // Normally, a sequential nine-digit number assigned by the\n  // USSPACECOM in order of launch or discovery.\n  public catalogNumber = 0;\n\n  // Keplerian orbital elements, plus some others used in\n  // producing the TLE representation.\n  // See: https://en.wikipedia.org/wiki/Orbital_elements\n  // Semi-major axis is the sum of the periapsis and apoapsis\n  // distances divided by two.\n  // public semiMajorAxis: number;\n  // Inclination is the vertical tilt of the ellipse with\n  // respect to the reference plane.\n  public inclination: number;\n  // The right ascension of the ascending node is the angle\n  // from a specified reference direction, called the origin\n  // of longitude, to the direction of the ascending node.\n  public longitude: number;\n  // Eccentricity represents the shape of the orbital ellipse,\n  // describing how much it is elongated compared to a circle.\n  public eccentricity: number;\n  // The argument of perigee is, parametrically, the angle\n  // from the body's ascending node to its periapsis, measured\n  // in the direction of motion.\n  public perigee: number;\n  // Mean motion is revolutions per day.\n  public motion: number;\n  // Mean anomaly is the fraction of an elliptical orbit's\n  // period that has elapsed since the orbiting body passed\n  // periapsis.\n  public anomaly: number;\n  // TODO: Again, think on this. Could be prohibitive, but\n  // maybe we can exclude from target consensus data model?\n  // Revolution number (typically at a given epoch) is just\n  // a counter, again normally tracked by\n  // This will not be tracked here.\n  public revolution = 1;\n  // Will leave this at unclassified for now.\n  public classification: \"U\" | \"C\" | \"S\" = \"U\";\n\n  // TODO: Comment this\n  public orbit: {\n    semiMajorAxis: number;\n    eccentricity: number;\n    inclination: number;\n    longitudeAscendingNode: number;\n    argumentPeriapsis: number;\n    trueAnomalyAtEpoch: number;\n  };\n\n  public ballisticCoefficient: number;\n\n  // Variables used to calculate the ballistic coefficient.\n  public volume: number; // In m^3.\n  public mass: number; // In kg.\n  public diameter: number; // In km.\n  public drag = 0.47; // Drag coefficient of a sphere.\n  public density = 2700.0; // Density of aluminum. kg/m^3\n\n  // TODO: Make into an enum.\n  material: string;\n\n  // TODO: Move to constants.\n  // Constants\n  earthRadius: number = 6371; // in km\n\n  /**\n   * A small point object representing orbiting debris.\n   */\n  constructor(scene: THREE.Scene) {\n    // Generate random position in low earth orbit\n    const altitude = Math.floor(Math.random() * 1300) + 700; // altitude between 700-2000 km\n    const longitude = Math.random() * 360; // random longitude\n    const latitude = Math.random() * 180 - 90; // random latitude\n\n    // Convert spherical coordinates to Cartesian coordinates\n    const x =\n      (this.earthRadius + altitude) * Math.cos(latitude) * Math.cos(longitude);\n    const y =\n      (this.earthRadius + altitude) * Math.cos(latitude) * Math.sin(longitude);\n    const z = (this.earthRadius + altitude) * Math.sin(latitude);\n\n    this.position = { x, y, z };\n\n    // Generate random elliptical orbit path\n    this.orbit = {\n      semiMajorAxis: Random.number(700, 2000), // semi-major axis between 1300-2000 km\n      eccentricity: Random.number(0, 0.5),\n\n      // TODO: I think more common around 80-100..?\n      // Inclination between the plane of the orbit and the reference plane.\n      // 80-100 is a polar orbit.\n      inclination: Random.number(0, 100), // inclination between 0-180 degrees\n\n      // Longitude (☊).\n      longitudeAscendingNode: Random.number(0, 360),\n      // Periapsis (ω): the angle measured along the orbit from the ascending node to\n      // the periapsis.\n      argumentPeriapsis: Random.number(0, 360),\n      // the angle measured along the orbital path from the periapsis to the satellite's\n      // current position, measured at a specific reference time known as the epoch.\n      // It describes the satellite's position along its orbit at a particular point in time.\n      trueAnomalyAtEpoch: Random.number(0, 360),\n    };\n\n    // Other properties (random values for demonstration)\n    this.material = \"Metal\";\n    this.mass = Random.number(1.0, 300.0); // random value\n    this.diameter = Random.number(0.1, 1); // random value\n    this.drag = Random.number(1.0, 2.2); // random value\n\n    const materialDensity = MATERIAL_DENSITY_MAP[this.material];\n    this.density = Random.number(materialDensity - 100, materialDensity + 100); // random value\n\n    this.volume = (4 / 3) * Math.PI * Math.pow(this.diameter / 2, 3); // random value\n\n    // Derive ballistic coefficient using the density-based formula.\n    this.ballisticCoefficient = 0.5 * this.density * this.diameter * this.drag;\n\n    const geometry = new THREE.SphereGeometry(1, 1, 1);\n    const material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color().setHSL(0.9, 0.9, 0.9, THREE.SRGBColorSpace),\n      side: THREE.DoubleSide,\n      alphaToCoverage: true,\n    });\n    this.mesh = new THREE.Mesh(geometry, material);\n\n    // Determine the initial position of the MMOD at random.\n    // Points on the surface of a sphere can be expressed using two\n    // spherical coordinates, theta and phi with 0 < theta < 2pi and\n    // 0 < phi < pi.\n    // Generate random values for theta and phi.\n    const theta = Random.number(0.01, 2 * Math.PI);\n    const phi = Math.acos(Random.number(-1, 1));\n    // TODO: Vary the radius slightly.\n    // Convert theta and phi into cartesian coordinates for the mesh.\n    // The LEO radius will be varied slightly by a modifier, targeting\n    // anywhere from 1000 km to 2000 km above the surface of the earth.\n    this.mesh.position.x = LEO_RADIUS * Math.cos(theta) * Math.sin(phi);\n    this.mesh.position.y = LEO_RADIUS * Math.sin(theta) * Math.sin(phi);\n    this.mesh.position.z = LEO_RADIUS * Math.cos(phi);\n    this.mesh.scale.x = this.mesh.scale.y = this.mesh.scale.z = MMOD_SCALE;\n\n    // Set mean motion at random.\n    // Initial speed (scalar) should be anywhere from 6-9 km/s.\n    const initialSpeed = Random.number(6000, 9000); // In m/s.\n    // Convert this to approximate (non-elliptical) revolutions per day.\n    const circumference = 46357.341; // 2pi * 7378 (mean LEO).\n    const dayDistanceTraveled = initialSpeed * 86400; // Seconds in a day.\n    this.motion = dayDistanceTraveled / circumference;\n\n    // Set inclination at random.\n    this.inclination = Random.number(40.0, 60.0);\n\n    // Set eccentricity at random.\n    this.eccentricity = Random.number(0.0, 0.0009);\n\n    // Set argument of perigee at random.\n    this.perigee = Random.number(100.0, 150.0);\n\n    // Set mean anomaly at random.\n    this.anomaly = Random.number(300.0, 350.0);\n\n    // Set longitude at random.\n    this.longitude = Random.number(200, 300);\n\n    // Set mass, diameter at random.\n    this.mass = Random.number(0.01, 0.2);\n    this.diameter = Random.number(0.0001, 0.0003);\n\n    scene.add(this.mesh);\n  }\n\n  /**\n   * Proceed to the next animation frame. Reposition the\n   * @param timestamp Time in seconds since init. It's assumed that we init at 0.\n   */\n  public step(timestamp: number): void {\n    // Logic to calculate new position based on timestamp.\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2.\n    const earthMass = 5.972e24; // Earth mass in kg.\n\n    // Convert timestamp to seconds.\n    const t = timestamp / 1000;\n\n    // Calculate mean anomaly (M) based on Kepler's equation.\n    const n = Math.sqrt(\n      (G * earthMass) / Math.pow(this.orbit.semiMajorAxis * 1000, 3)\n    ); // Mean motion.\n    let meanAnomaly = this.orbit.trueAnomalyAtEpoch - n * t;\n\n    // Iteratively solve Kepler's equation for eccentric anomaly (E).\n    let eccentricAnomaly = meanAnomaly; // Initial guess for eccentric anomaly.\n    let delta = 1;\n    const tolerance = 1e-10; // Tolerance for convergence.\n    while (Math.abs(delta) > tolerance) {\n      const f =\n        eccentricAnomaly -\n        this.orbit.eccentricity * Math.sin(eccentricAnomaly) -\n        meanAnomaly;\n      const fPrime = 1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly);\n      delta = f / fPrime;\n      eccentricAnomaly -= delta;\n    }\n\n    // Calculate true anomaly (ν) from eccentric anomaly (E).\n    const cosTrueAnomaly =\n      (Math.cos(eccentricAnomaly) - this.orbit.eccentricity) /\n      (1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly));\n    const sinTrueAnomaly =\n      (Math.sqrt(1 - this.orbit.eccentricity * this.orbit.eccentricity) *\n        Math.sin(eccentricAnomaly)) /\n      (1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly));\n    const trueAnomaly = Math.atan2(sinTrueAnomaly, cosTrueAnomaly);\n\n    // Calculate distance from center of the Earth to the satellite (r) using vis-viva equation.\n    const radius =\n      (this.orbit.semiMajorAxis *\n        1000 *\n        (1 - this.orbit.eccentricity * this.orbit.eccentricity)) /\n      (1 + this.orbit.eccentricity * Math.cos(trueAnomaly));\n\n    // Calculate position in orbital plane (x', y').\n    const xPrime = radius * Math.cos(trueAnomaly);\n    const yPrime = radius * Math.sin(trueAnomaly);\n\n    // Rotate position to align with orbital elements.\n    const cosLongitudeAscendingNode = Math.cos(\n      this.orbit.longitudeAscendingNode\n    );\n    const sinLongitudeAscendingNode = Math.sin(\n      this.orbit.longitudeAscendingNode\n    );\n    const cosArgumentPeriapsis = Math.cos(this.orbit.argumentPeriapsis);\n    const sinArgumentPeriapsis = Math.sin(this.orbit.argumentPeriapsis);\n    const cosInclination = Math.cos(this.orbit.inclination);\n    const sinInclination = Math.sin(this.orbit.inclination);\n\n    const x =\n      xPrime *\n        (cosLongitudeAscendingNode * cosArgumentPeriapsis -\n          sinLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination) -\n      yPrime *\n        (sinLongitudeAscendingNode * cosArgumentPeriapsis +\n          cosLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination);\n    const y =\n      xPrime *\n        (cosLongitudeAscendingNode * sinArgumentPeriapsis +\n          sinLongitudeAscendingNode * cosArgumentPeriapsis * cosInclination) +\n      yPrime *\n        (cosLongitudeAscendingNode * cosArgumentPeriapsis -\n          sinLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination);\n    const z =\n      xPrime * (sinLongitudeAscendingNode * sinInclination) +\n      yPrime * (cosLongitudeAscendingNode * sinInclination);\n\n    // Update object position.\n    this.position = { x, y, z };\n\n    // Finally, convert to three.js coordinate space and update the mesh's\n    // position.\n    const threePosition = this.toThreeJSPosition();\n    this.mesh.position.x = threePosition.x;\n    this.mesh.position.y = threePosition.y;\n    this.mesh.position.z = threePosition.z;\n  }\n\n  public tle(timestamp: Date): TLE {\n    // Line 1\n    const firstDerivativeMeanMotion = this.getFirstDerivativeMeanMotion();\n    const secondDerivativeMeanMotion = this.getSecondDerivativeMeanMotion();\n    const BSTARDragTerm = this.getBSTARDragTerm();\n    const line1 = `1 ${this.catalogNumber}U 00000A ${timestamp\n      .toISOString()\n      .slice(2, 10)\n      .replace(/-/g, \"\")} .${firstDerivativeMeanMotion\n      .toString()\n      .replace(/-/g, \" \")\n      .padStart(8, \" \")}${\n      secondDerivativeMeanMotion > 0\n        ? secondDerivativeMeanMotion.toFixed(8).padStart(8, \" \")\n        : \"  .00000000\"\n    }-${BSTARDragTerm.toFixed(4).replace(/-/g, \" \").padStart(6, \" \")} 0`;\n\n    // Line 2\n    const line2 = `2 ${this.catalogNumber} ${this.inclination\n      .toFixed(4)\n      .padStart(8, \" \")}${this.orbit.longitudeAscendingNode\n      .toFixed(4)\n      .padStart(8, \" \")}${(this.eccentricity * 1e7)\n      .toFixed(7)\n      .replace(/\\.?0+$/, \"\")\n      .padStart(7, \" \")}${this.orbit.argumentPeriapsis\n      .toFixed(4)\n      .padStart(8, \" \")}${this.getMeanAnomaly(timestamp.getUTCMilliseconds())\n      .toFixed(4)\n      .padStart(8, \" \")}${this.getMeanMotion(this.orbit.semiMajorAxis, MU_EARTH)\n      .toFixed(11)\n      .replace(\".\", \"\")}`;\n\n    return [line1, line2];\n  }\n\n  private getMeanMotion(a: number, mu: number): number {\n    // Semi-major axis 'a' in meters\n    // Gravitational parameter 'mu' in m^3/s^2\n\n    // Calculate mean motion (n)\n    const n = Math.sqrt(mu / Math.pow(a, 3));\n\n    // Convert mean motion to revolutions per day\n    const meanMotionRevPerDay = n * (86400 / (2 * Math.PI));\n\n    return meanMotionRevPerDay;\n  }\n\n  private getFirstDerivativeMeanMotion(): number {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Calculate the semi-major axis of the orbit in meters\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n\n    // Calculate the mean motion (n) in radians per second\n    const meanMotion = Math.sqrt(\n      (G * earthMass) / Math.pow(semiMajorAxisMeters, 3)\n    );\n\n    // Return the first derivative of mean motion\n    return (\n      -1.5 * meanMotion * this.orbit.eccentricity * this.orbit.eccentricity\n    );\n  }\n\n  // Function to calculate the second derivative of mean motion\n  private getSecondDerivativeMeanMotion(): number {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Calculate the semi-major axis of the orbit in meters\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n\n    // Calculate the mean motion (n) in radians per second\n    const meanMotion = Math.sqrt(\n      (G * earthMass) / Math.pow(semiMajorAxisMeters, 3)\n    );\n\n    // Calculate the eccentricity squared\n    const eccentricitySquared =\n      this.orbit.eccentricity * this.orbit.eccentricity;\n\n    // Return the second derivative of mean motion\n    return (\n      (-meanMotion * eccentricitySquared * (4 * eccentricitySquared - 5)) /\n      semiMajorAxisMeters\n    );\n  }\n\n  private getBSTARDragTerm(): number {\n    // Constants\n    // TODO: Move to constants!\n    const earthRadius = 6371; // Earth radius in kilometers\n    const earthMass = 5.972e24; // Earth mass in kg\n    const dragCoefficient = 2.2; // Example drag coefficient\n\n    // Calculate the cross-sectional area of the object\n    const crossSectionalArea = Math.PI * Math.pow(this.diameter / 2, 2); // Assuming spherical object\n\n    // Calculate the ballistic coefficient\n    const ballisticCoefficient =\n      dragCoefficient * (crossSectionalArea / this.mass);\n\n    // Calculate the atmospheric density at the object's altitude\n    const altitudeFromEarthCenter = this.getPositionMagnitude() - earthRadius;\n    const altitudeFromSurface = altitudeFromEarthCenter - this.earthRadius;\n    const density = this.getAtmosphericDensity(altitudeFromSurface); // Example call to get atmospheric density\n\n    // Calculate the BSTAR drag term\n    return -0.5 * ballisticCoefficient * density;\n  }\n\n  private getMeanAnomaly(timestamp: number): number {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Convert timestamp to seconds\n    const t = timestamp / 1000;\n\n    // Calculate mean motion (n) in radians per second\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n    const n = Math.sqrt((G * earthMass) / Math.pow(semiMajorAxisMeters, 3));\n\n    // Calculate mean anomaly (M) based on Kepler's equation\n    const M = this.orbit.trueAnomalyAtEpoch - n * t;\n\n    return M;\n  }\n\n  private getPositionMagnitude(): number {\n    return Math.sqrt(\n      this.position.x * this.position.x +\n        this.position.y * this.position.y +\n        this.position.z * this.position.z\n    );\n  }\n\n  // Function to estimate atmospheric density at a given altitude\n  private getAtmosphericDensity(altitude: number): number {\n    // Constants for US Standard Atmosphere model.\n    // NOTE: This is just for the troposphere (up to 11k km).\n    const T0 = 288.15; // Sea level temperature in Kelvin\n    const lapseRate = 0.0065; // Temperature lapse rate in Kelvin per meter\n    const R = 8.31447; // Universal gas constant in J/(mol*K)\n    const g0 = 9.80665; // Standard gravity in m/s^2\n    const M = 0.0289644; // Molar mass of dry air in kg/mol\n\n    // Calculate temperature at given altitude using lapse rate model.\n    const temperature = T0 - lapseRate * altitude;\n\n    // Calculate pressure at given altitude using hydrostatic equation.\n    const pressure =\n      101325 *\n      Math.pow(1 - (lapseRate * altitude) / T0, (g0 * M) / (R * lapseRate));\n\n    // Calculate density using ideal gas law.\n    return (pressure * M) / (R * temperature);\n  }\n\n  // Function to convert position to three.js coordinates\n  private toThreeJSPosition(): { x: number; y: number; z: number } {\n    // Scaling down the position to fit with three.js coordinates (assuming earth sphere radius is 16)\n    const scaleFactor = 16 / 6371; // TODO: Should be constants!\n    return {\n      x: this.position.x * scaleFactor,\n      y: this.position.y * scaleFactor,\n      z: this.position.z * scaleFactor,\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}