{"ast":null,"code":"import * as THREE from \"three\";\nimport { MMOD_SCALE } from \"../helpers/Constants\";\nimport { Random } from \"../helpers/Random\";\n// TODO: Move these to constants.\nconst MATERIAL_DENSITY_MAP = {\n  Metal: 7800,\n  // Density of metal in kg/m^3\n  Plastic: 950,\n  // Density of plastic in kg/m^3\n  Composite: 1600 // Density of composite in kg/m^3\n  // TODO: Add more materials as needed\n};\n/**\n * The gravitational parameter (μ) is a constant value for a particular\n * celestial body and represents the product of the gravitational constant (G) and the\n * mass (M) of the central body (usually a planet or a star). For Earth, μ is approximately\n * 3.986×10^14 m^3/s^2.\n */\nconst MU_EARTH = 3.986e14;\nlet COUNT = 0;\nexport class MMOD {\n  /**\n   * A small point object representing orbiting debris.\n   */\n  constructor(scene) {\n    // The three js object to be rendered.\n    this.mesh = void 0;\n    this.position = void 0;\n    // TODO: Think on this one.\n    // Normally, a sequential nine-digit number assigned by the\n    // USSPACECOM in order of launch or discovery.\n    this.catalogNumber = 0;\n    // Keplerian orbital elements, plus some others used in\n    // producing the TLE representation.\n    // See: https://en.wikipedia.org/wiki/Orbital_elements\n    // Semi-major axis is the sum of the periapsis and apoapsis\n    // distances divided by two.\n    // public semiMajorAxis: number;\n    // Inclination is the vertical tilt of the ellipse with\n    // respect to the reference plane.\n    // public inclination: number;\n    // The right ascension of the ascending node is the angle\n    // from a specified reference direction, called the origin\n    // of longitude, to the direction of the ascending node.\n    // public longitude: number;\n    // Eccentricity represents the shape of the orbital ellipse,\n    // describing how much it is elongated compared to a circle.\n    // public eccentricity: number;\n    // The argument of perigee is, parametrically, the angle\n    // from the body's ascending node to its periapsis, measured\n    // in the direction of motion.\n    // public perigee: number;\n    // Mean motion is revolutions per day.\n    // public motion: number;\n    // Mean anomaly is the fraction of an elliptical orbit's\n    // period that has elapsed since the orbiting body passed\n    // periapsis.\n    // public anomaly: number;\n    // TODO: Again, think on this. Could be prohibitive, but\n    // maybe we can exclude from target consensus data model?\n    // Revolution number (typically at a given epoch) is just\n    // a counter, again normally tracked by\n    // This will not be tracked here.\n    this.revolution = 1;\n    // Will leave this at unclassified for now.\n    this.classification = \"U\";\n    // TODO: Comment this\n    this.orbit = void 0;\n    this.ballisticCoefficient = void 0;\n    // Variables used to calculate the ballistic coefficient.\n    this.volume = void 0;\n    // In m^3.\n    this.mass = void 0;\n    // In kg.\n    this.diameter = void 0;\n    // In km.\n    this.drag = 0.47;\n    // Drag coefficient of a sphere.\n    this.density = 2700.0;\n    // Density of aluminum. kg/m^3\n    // TODO: Make into an enum.\n    this.material = void 0;\n    // TODO: Move to constants.\n    // Constants\n    this.earthRadius = 6371;\n    // in km\n    this.shouldLog = false;\n    // TODO: test remove\n    if (COUNT === 0) {\n      this.shouldLog = true;\n    }\n    COUNT++;\n\n    // Generate random position in low earth orbit\n    const altitude = Math.floor(Math.random() * 1300) + 700; // altitude between 700-2000 km\n    const longitude = Math.random() * 360; // random longitude\n    const latitude = Math.random() * 180 - 90; // random latitude\n\n    // Convert spherical coordinates to Cartesian coordinates\n    const x = (this.earthRadius + altitude) * Math.cos(latitude) * Math.cos(longitude);\n    const y = (this.earthRadius + altitude) * Math.cos(latitude) * Math.sin(longitude);\n    const z = (this.earthRadius + altitude) * Math.sin(latitude);\n    this.position = {\n      x,\n      y,\n      z\n    };\n\n    // Generate random elliptical orbit path\n    this.orbit = {\n      semiMajorAxis: Random.number(700, 2000),\n      // semi-major axis between 1300-2000 km\n      eccentricity: Random.number(0, 0.5),\n      // TODO: I think more common around 80-100..?\n      // Inclination between the plane of the orbit and the reference plane.\n      // 80-100 is a polar orbit.\n      inclination: Random.number(0, 100),\n      // inclination between 0-180 degrees\n\n      // Longitude (☊).\n      longitudeAscendingNode: Random.number(0, 360),\n      // Periapsis (ω): the angle measured along the orbit from the ascending node to\n      // the periapsis.\n      argumentPeriapsis: Random.number(0, 360),\n      // the angle measured along the orbital path from the periapsis to the satellite's\n      // current position, measured at a specific reference time known as the epoch.\n      // It describes the satellite's position along its orbit at a particular point in time.\n      trueAnomalyAtEpoch: Random.number(0, 360)\n    };\n    console.log(\"ORBIT DETERMINED: \", this.orbit);\n\n    // Other properties (random values for demonstration)\n    this.material = \"Metal\";\n    this.mass = Random.number(1.0, 300.0); // random value\n    this.diameter = Random.number(0.1, 1); // random value\n    this.drag = Random.number(1.0, 2.2); // random value\n\n    const materialDensity = MATERIAL_DENSITY_MAP[this.material];\n    this.density = Random.number(materialDensity - 100, materialDensity + 100); // random value\n\n    this.volume = 4 / 3 * Math.PI * Math.pow(this.diameter / 2, 3); // random value\n\n    // Derive ballistic coefficient using the density-based formula.\n    this.ballisticCoefficient = 0.5 * this.density * this.diameter * this.drag;\n    const geometry = new THREE.SphereGeometry(32, 4, 4);\n    const material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color().setHSL(0.9, 0.9, 0.9, THREE.SRGBColorSpace),\n      side: THREE.DoubleSide,\n      alphaToCoverage: true\n    });\n    this.mesh = new THREE.Mesh(geometry, material);\n\n    // Determine the initial position of the MMOD at random.\n    // Points on the surface of a sphere can be expressed using two\n    // spherical coordinates, theta and phi with 0 < theta < 2pi and\n    // 0 < phi < pi.\n    // Generate random values for theta and phi.\n    // const theta = Random.number(0.01, 2 * Math.PI);\n    // const phi = Math.acos(Random.number(-1, 1));\n    // TODO: Vary the radius slightly.\n    // Convert theta and phi into cartesian coordinates for the mesh.\n    // The LEO radius will be varied slightly by a modifier, targeting\n    // anywhere from 1000 km to 2000 km above the surface of the earth.\n    const threePosition = this.toThreeJSPosition();\n    this.mesh.position.x = threePosition.x; //LEO_RADIUS * Math.cos(theta) * Math.sin(phi);\n    this.mesh.position.y = threePosition.y; //LEO_RADIUS * Math.sin(theta) * Math.sin(phi);\n    this.mesh.position.z = threePosition.z; //LEO_RADIUS * Math.cos(phi);\n    this.mesh.scale.x = this.mesh.scale.y = this.mesh.scale.z = MMOD_SCALE;\n\n    // Set mean motion at random.\n    // Initial speed (scalar) should be anywhere from 6-9 km/s.\n    // const initialSpeed = Random.number(6000, 9000); // In m/s.\n    // // Convert this to approximate (non-elliptical) revolutions per day.\n    // const circumference = 46357.341; // 2pi * 7378 (mean LEO).\n    // const dayDistanceTraveled = initialSpeed * 86400; // Seconds in a day.\n    // this.motion = dayDistanceTraveled / circumference;\n\n    scene.add(this.mesh);\n  }\n\n  /**\n   * Proceed to the next animation frame. Reposition the\n   * @param timestamp Time in seconds since init. It's assumed that we init at 0.\n   */\n  step(timestamp) {\n    if (this.shouldLog) {\n      console.log(\"Current position MMOD:\", this.position.x, this.position.y, this.position.z, ...Array.from(Object.values(this.toThreeJSPosition())));\n    }\n\n    // TODO: Move to constants!\n    // Logic to calculate new position based on timestamp.\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2.\n    const earthMass = 5.972e24; // Earth mass in kg.\n\n    // Convert timestamp to seconds.\n    const t = timestamp / 1000;\n\n    // Validate input values: semiMajorAxis should be positive, eccentricity should be between 0 and 1.\n    if (this.orbit.semiMajorAxis <= 0 || this.orbit.eccentricity < 0 || this.orbit.eccentricity >= 1) {\n      console.error(\"Invalid input values for semiMajorAxis or eccentricity.\", this.orbit.semiMajorAxis, this.orbit.eccentricity);\n      return; // Exit function early to prevent further calculations with invalid inputs.\n    }\n\n    // Calculate mean anomaly (M) based on Kepler's equation.\n    const n = Math.sqrt(G * earthMass / Math.pow(this.orbit.semiMajorAxis * 1000, 3)); // Mean motion.\n    let meanAnomaly = this.orbit.trueAnomalyAtEpoch - n * t;\n\n    // Iteratively solve Kepler's equation for eccentric anomaly (E).\n    let eccentricAnomaly = meanAnomaly; // Initial guess for eccentric anomaly.\n    let delta = 1;\n    const tolerance = 1e-10; // Tolerance for convergence.\n    while (Math.abs(delta) > tolerance) {\n      const f = eccentricAnomaly - this.orbit.eccentricity * Math.sin(eccentricAnomaly) - meanAnomaly;\n      const fPrime = 1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly);\n      delta = f / fPrime;\n      eccentricAnomaly -= delta;\n    }\n    console.log(\"stuff 1\", meanAnomaly, eccentricAnomaly, delta);\n\n    // Calculate true anomaly (ν) from eccentric anomaly (E).\n    const trueAnomaly = 2 * Math.atan(Math.sqrt((1 + this.orbit.eccentricity) / (1 - this.orbit.eccentricity)) * Math.tan(eccentricAnomaly / 2));\n\n    // Calculate distance from center of the Earth to the satellite (r) using vis-viva equation.\n    const radius = this.orbit.semiMajorAxis * (1 - this.orbit.eccentricity * this.orbit.eccentricity) / (1 + this.orbit.eccentricity * Math.cos(trueAnomaly));\n\n    // Calculate position in orbital plane (x', y').\n    const xPrime = radius * Math.cos(trueAnomaly);\n    const yPrime = radius * Math.sin(trueAnomaly);\n    console.log(trueAnomaly, radius, xPrime, yPrime);\n\n    // // Calculate true anomaly (ν) from eccentric anomaly (E).\n    // const cosTrueAnomaly =\n    //   (Math.cos(eccentricAnomaly) - this.orbit.eccentricity) /\n    //   (1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly));\n    // const sinTrueAnomaly =\n    //   (Math.sqrt(1 - this.orbit.eccentricity * this.orbit.eccentricity) *\n    //     Math.sin(eccentricAnomaly)) /\n    //   (1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly));\n    // const trueAnomaly = Math.atan2(sinTrueAnomaly, cosTrueAnomaly);\n\n    // // Calculate distance from center of the Earth to the satellite (r) using vis-viva equation.\n    // const radius =\n    //   (this.orbit.semiMajorAxis *\n    //     1000 *\n    //     (1 - this.orbit.eccentricity * this.orbit.eccentricity)) /\n    //   (1 + this.orbit.eccentricity * Math.cos(trueAnomaly));\n\n    // // Calculate position in orbital plane (x', y').\n    // const xPrime = radius * Math.cos(trueAnomaly);\n    // const yPrime = radius * Math.sin(trueAnomaly);\n\n    // Rotate position to align with orbital elements.\n    const cosLongitudeAscendingNode = Math.cos(this.orbit.longitudeAscendingNode);\n    const sinLongitudeAscendingNode = Math.sin(this.orbit.longitudeAscendingNode);\n    const cosArgumentPeriapsis = Math.cos(this.orbit.argumentPeriapsis);\n    const sinArgumentPeriapsis = Math.sin(this.orbit.argumentPeriapsis);\n    const cosInclination = Math.cos(this.orbit.inclination);\n    const sinInclination = Math.sin(this.orbit.inclination);\n    console.log(cosLongitudeAscendingNode, sinLongitudeAscendingNode, cosArgumentPeriapsis, sinArgumentPeriapsis, cosInclination, sinInclination);\n    const x = xPrime * (cosLongitudeAscendingNode * cosArgumentPeriapsis - sinLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination) - yPrime * (sinLongitudeAscendingNode * cosArgumentPeriapsis + cosLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination);\n    const y = xPrime * (cosLongitudeAscendingNode * sinArgumentPeriapsis + sinLongitudeAscendingNode * cosArgumentPeriapsis * cosInclination) + yPrime * (cosLongitudeAscendingNode * cosArgumentPeriapsis - sinLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination);\n    const z = xPrime * (sinLongitudeAscendingNode * sinInclination) + yPrime * (cosLongitudeAscendingNode * sinInclination);\n\n    // Update object position.\n    this.position = {\n      x,\n      y,\n      z\n    };\n\n    // Finally, convert to three.js coordinate space and update the mesh's\n    // position.\n    const threePosition = this.toThreeJSPosition();\n    if (this.shouldLog) {\n      console.log(\"New position for mmod:\", this.position.x, this.position.y, this.position.z, threePosition.x, threePosition.y, threePosition.z);\n    }\n\n    // this.mesh.position.x = threePosition.x;\n    // this.mesh.position.y = threePosition.y;\n    // this.mesh.position.z = threePosition.z;\n  }\n  tle(timestamp) {\n    // Line 1\n    const firstDerivativeMeanMotion = this.getFirstDerivativeMeanMotion();\n    const secondDerivativeMeanMotion = this.getSecondDerivativeMeanMotion();\n    const BSTARDragTerm = this.getBSTARDragTerm();\n    const line1 = `1 ${this.catalogNumber}U 00000A ${timestamp.toISOString().slice(2, 10).replace(/-/g, \"\")} .${firstDerivativeMeanMotion.toString().replace(/-/g, \" \").padStart(8, \" \")}${secondDerivativeMeanMotion > 0 ? secondDerivativeMeanMotion.toFixed(8).padStart(8, \" \") : \"  .00000000\"}-${BSTARDragTerm.toFixed(4).replace(/-/g, \" \").padStart(6, \" \")} 0`;\n\n    // Line 2\n    const line2 = `2 ${this.catalogNumber} ${this.orbit.inclination.toFixed(4).padStart(8, \" \")}${this.orbit.longitudeAscendingNode.toFixed(4).padStart(8, \" \")}${(this.orbit.eccentricity * 1e7).toFixed(7).replace(/\\.?0+$/, \"\").padStart(7, \" \")}${this.orbit.argumentPeriapsis.toFixed(4).padStart(8, \" \")}${this.getMeanAnomaly(timestamp.getUTCMilliseconds()).toFixed(4).padStart(8, \" \")}${this.getMeanMotion(this.orbit.semiMajorAxis, MU_EARTH).toFixed(11).replace(\".\", \"\")}`;\n    return [line1, line2];\n  }\n  getMeanMotion(a, mu) {\n    // Semi-major axis 'a' in meters\n    // Gravitational parameter 'mu' in m^3/s^2\n\n    // Calculate mean motion (n)\n    const n = Math.sqrt(mu / Math.pow(a, 3));\n\n    // Convert mean motion to revolutions per day\n    const meanMotionRevPerDay = n * (86400 / (2 * Math.PI));\n    return meanMotionRevPerDay;\n  }\n  getFirstDerivativeMeanMotion() {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Calculate the semi-major axis of the orbit in meters\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n\n    // Calculate the mean motion (n) in radians per second\n    const meanMotion = Math.sqrt(G * earthMass / Math.pow(semiMajorAxisMeters, 3));\n\n    // Return the first derivative of mean motion\n    return -1.5 * meanMotion * this.orbit.eccentricity ** 2;\n  }\n\n  // Function to calculate the second derivative of mean motion\n  getSecondDerivativeMeanMotion() {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Calculate the semi-major axis of the orbit in meters\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n\n    // Calculate the mean motion (n) in radians per second\n    const meanMotion = Math.sqrt(G * earthMass / Math.pow(semiMajorAxisMeters, 3));\n\n    // Calculate the eccentricity squared\n    const eccentricitySquared = this.orbit.eccentricity * this.orbit.eccentricity;\n\n    // Return the second derivative of mean motion\n    return -meanMotion * eccentricitySquared * (4 * eccentricitySquared - 5) / semiMajorAxisMeters;\n  }\n  getBSTARDragTerm() {\n    // Constants\n    // TODO: Move to constants!\n    const earthRadius = 6371; // Earth radius in kilometers\n    const earthMass = 5.972e24; // Earth mass in kg\n    const dragCoefficient = 2.2; // Example drag coefficient\n\n    // Calculate the cross-sectional area of the object\n    const crossSectionalArea = Math.PI * Math.pow(this.diameter / 2, 2); // Assuming spherical object\n\n    // Calculate the ballistic coefficient\n    const ballisticCoefficient = dragCoefficient * (crossSectionalArea / this.mass);\n\n    // Calculate the atmospheric density at the object's altitude\n    const altitudeFromEarthCenter = this.getPositionMagnitude() - earthRadius;\n    const altitudeFromSurface = altitudeFromEarthCenter - this.earthRadius;\n    const density = this.getAtmosphericDensity(altitudeFromSurface); // Example call to get atmospheric density\n\n    // Calculate the BSTAR drag term\n    return -0.5 * ballisticCoefficient * density;\n  }\n  getMeanAnomaly(timestamp) {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Convert timestamp to seconds\n    const t = timestamp / 1000;\n\n    // Calculate mean motion (n) in radians per second\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n    const n = Math.sqrt(G * earthMass / Math.pow(semiMajorAxisMeters, 3));\n\n    // Calculate mean anomaly (M) based on Kepler's equation\n    const M = this.orbit.trueAnomalyAtEpoch - n * t;\n    return M;\n  }\n  getPositionMagnitude() {\n    return Math.sqrt(this.position.x * this.position.x + this.position.y * this.position.y + this.position.z * this.position.z);\n  }\n\n  // Function to estimate atmospheric density at a given altitude\n  getAtmosphericDensity(altitude) {\n    // Constants for US Standard Atmosphere model.\n    // NOTE: This is just for the troposphere (up to 11k km).\n    const T0 = 288.15; // Sea level temperature in Kelvin\n    const lapseRate = 0.0065; // Temperature lapse rate in Kelvin per meter\n    const R = 8.31447; // Universal gas constant in J/(mol*K)\n    const g0 = 9.80665; // Standard gravity in m/s^2\n    const M = 0.0289644; // Molar mass of dry air in kg/mol\n\n    // Calculate temperature at given altitude using lapse rate model.\n    const temperature = T0 - lapseRate * altitude;\n\n    // Calculate pressure at given altitude using hydrostatic equation.\n    const pressure = 101325 * Math.pow(1 - lapseRate * altitude / T0, g0 * M / (R * lapseRate));\n\n    // Calculate density using ideal gas law.\n    return pressure * M / (R * temperature);\n  }\n\n  // Function to convert position to three.js coordinates\n  toThreeJSPosition() {\n    // Scaling down the position to fit with three.js coordinates (assuming earth sphere radius is 16)\n    const scaleFactor = 6 / 6371; // TODO: Should be constants!\n    return {\n      x: this.position.x * scaleFactor,\n      y: this.position.y * scaleFactor,\n      z: this.position.z * scaleFactor\n    };\n  }\n}","map":{"version":3,"names":["THREE","MMOD_SCALE","Random","MATERIAL_DENSITY_MAP","Metal","Plastic","Composite","MU_EARTH","COUNT","MMOD","constructor","scene","mesh","position","catalogNumber","revolution","classification","orbit","ballisticCoefficient","volume","mass","diameter","drag","density","material","earthRadius","shouldLog","altitude","Math","floor","random","longitude","latitude","x","cos","y","sin","z","semiMajorAxis","number","eccentricity","inclination","longitudeAscendingNode","argumentPeriapsis","trueAnomalyAtEpoch","console","log","materialDensity","PI","pow","geometry","SphereGeometry","MeshPhongMaterial","color","Color","setHSL","SRGBColorSpace","side","DoubleSide","alphaToCoverage","Mesh","threePosition","toThreeJSPosition","scale","add","step","timestamp","Array","from","Object","values","G","earthMass","t","error","n","sqrt","meanAnomaly","eccentricAnomaly","delta","tolerance","abs","f","fPrime","trueAnomaly","atan","tan","radius","xPrime","yPrime","cosLongitudeAscendingNode","sinLongitudeAscendingNode","cosArgumentPeriapsis","sinArgumentPeriapsis","cosInclination","sinInclination","tle","firstDerivativeMeanMotion","getFirstDerivativeMeanMotion","secondDerivativeMeanMotion","getSecondDerivativeMeanMotion","BSTARDragTerm","getBSTARDragTerm","line1","toISOString","slice","replace","toString","padStart","toFixed","line2","getMeanAnomaly","getUTCMilliseconds","getMeanMotion","a","mu","meanMotionRevPerDay","semiMajorAxisMeters","meanMotion","eccentricitySquared","dragCoefficient","crossSectionalArea","altitudeFromEarthCenter","getPositionMagnitude","altitudeFromSurface","getAtmosphericDensity","M","T0","lapseRate","R","g0","temperature","pressure","scaleFactor"],"sources":["/home/jake/ptolemy/mmod/packages/kepler/src/scene/MMOD.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { LEO_RADIUS, MMOD_SCALE } from \"../helpers/Constants\";\nimport { Random } from \"../helpers/Random\";\n\nexport type TLE = [string, string];\n\n// TODO: Move these to constants.\nconst MATERIAL_DENSITY_MAP: { [material: string]: number } = {\n  Metal: 7800, // Density of metal in kg/m^3\n  Plastic: 950, // Density of plastic in kg/m^3\n  Composite: 1600, // Density of composite in kg/m^3\n  // TODO: Add more materials as needed\n};\n/**\n * The gravitational parameter (μ) is a constant value for a particular\n * celestial body and represents the product of the gravitational constant (G) and the\n * mass (M) of the central body (usually a planet or a star). For Earth, μ is approximately\n * 3.986×10^14 m^3/s^2.\n */\nconst MU_EARTH = 3.986e14;\n\nlet COUNT = 0;\n\nexport class MMOD {\n  // The three js object to be rendered.\n  public readonly mesh: THREE.Mesh;\n\n  position: { x: number; y: number; z: number };\n\n  // TODO: Think on this one.\n  // Normally, a sequential nine-digit number assigned by the\n  // USSPACECOM in order of launch or discovery.\n  public catalogNumber = 0;\n\n  // Keplerian orbital elements, plus some others used in\n  // producing the TLE representation.\n  // See: https://en.wikipedia.org/wiki/Orbital_elements\n  // Semi-major axis is the sum of the periapsis and apoapsis\n  // distances divided by two.\n  // public semiMajorAxis: number;\n  // Inclination is the vertical tilt of the ellipse with\n  // respect to the reference plane.\n  // public inclination: number;\n  // The right ascension of the ascending node is the angle\n  // from a specified reference direction, called the origin\n  // of longitude, to the direction of the ascending node.\n  // public longitude: number;\n  // Eccentricity represents the shape of the orbital ellipse,\n  // describing how much it is elongated compared to a circle.\n  // public eccentricity: number;\n  // The argument of perigee is, parametrically, the angle\n  // from the body's ascending node to its periapsis, measured\n  // in the direction of motion.\n  // public perigee: number;\n  // Mean motion is revolutions per day.\n  // public motion: number;\n  // Mean anomaly is the fraction of an elliptical orbit's\n  // period that has elapsed since the orbiting body passed\n  // periapsis.\n  // public anomaly: number;\n  // TODO: Again, think on this. Could be prohibitive, but\n  // maybe we can exclude from target consensus data model?\n  // Revolution number (typically at a given epoch) is just\n  // a counter, again normally tracked by\n  // This will not be tracked here.\n  public revolution = 1;\n  // Will leave this at unclassified for now.\n  public classification: \"U\" | \"C\" | \"S\" = \"U\";\n\n  // TODO: Comment this\n  public orbit: {\n    semiMajorAxis: number;\n    eccentricity: number;\n    inclination: number;\n    longitudeAscendingNode: number;\n    argumentPeriapsis: number;\n    trueAnomalyAtEpoch: number;\n  };\n\n  public ballisticCoefficient: number;\n\n  // Variables used to calculate the ballistic coefficient.\n  public volume: number; // In m^3.\n  public mass: number; // In kg.\n  public diameter: number; // In km.\n  public drag = 0.47; // Drag coefficient of a sphere.\n  public density = 2700.0; // Density of aluminum. kg/m^3\n\n  // TODO: Make into an enum.\n  material: string;\n\n  // TODO: Move to constants.\n  // Constants\n  earthRadius: number = 6371; // in km\n\n  shouldLog = false;\n\n  /**\n   * A small point object representing orbiting debris.\n   */\n  constructor(scene: THREE.Scene) {\n    // TODO: test remove\n    if (COUNT === 0) {\n      this.shouldLog = true;\n    }\n    COUNT++;\n\n    // Generate random position in low earth orbit\n    const altitude = Math.floor(Math.random() * 1300) + 700; // altitude between 700-2000 km\n    const longitude = Math.random() * 360; // random longitude\n    const latitude = Math.random() * 180 - 90; // random latitude\n\n    // Convert spherical coordinates to Cartesian coordinates\n    const x =\n      (this.earthRadius + altitude) * Math.cos(latitude) * Math.cos(longitude);\n    const y =\n      (this.earthRadius + altitude) * Math.cos(latitude) * Math.sin(longitude);\n    const z = (this.earthRadius + altitude) * Math.sin(latitude);\n\n    this.position = { x, y, z };\n\n    // Generate random elliptical orbit path\n    this.orbit = {\n      semiMajorAxis: Random.number(700, 2000), // semi-major axis between 1300-2000 km\n      eccentricity: Random.number(0, 0.5),\n\n      // TODO: I think more common around 80-100..?\n      // Inclination between the plane of the orbit and the reference plane.\n      // 80-100 is a polar orbit.\n      inclination: Random.number(0, 100), // inclination between 0-180 degrees\n\n      // Longitude (☊).\n      longitudeAscendingNode: Random.number(0, 360),\n      // Periapsis (ω): the angle measured along the orbit from the ascending node to\n      // the periapsis.\n      argumentPeriapsis: Random.number(0, 360),\n      // the angle measured along the orbital path from the periapsis to the satellite's\n      // current position, measured at a specific reference time known as the epoch.\n      // It describes the satellite's position along its orbit at a particular point in time.\n      trueAnomalyAtEpoch: Random.number(0, 360),\n    };\n\n    console.log(\"ORBIT DETERMINED: \", this.orbit);\n\n    // Other properties (random values for demonstration)\n    this.material = \"Metal\";\n    this.mass = Random.number(1.0, 300.0); // random value\n    this.diameter = Random.number(0.1, 1); // random value\n    this.drag = Random.number(1.0, 2.2); // random value\n\n    const materialDensity = MATERIAL_DENSITY_MAP[this.material];\n    this.density = Random.number(materialDensity - 100, materialDensity + 100); // random value\n\n    this.volume = (4 / 3) * Math.PI * Math.pow(this.diameter / 2, 3); // random value\n\n    // Derive ballistic coefficient using the density-based formula.\n    this.ballisticCoefficient = 0.5 * this.density * this.diameter * this.drag;\n\n    const geometry = new THREE.SphereGeometry(32, 4, 4);\n    const material = new THREE.MeshPhongMaterial({\n      color: new THREE.Color().setHSL(0.9, 0.9, 0.9, THREE.SRGBColorSpace),\n      side: THREE.DoubleSide,\n      alphaToCoverage: true,\n    });\n    this.mesh = new THREE.Mesh(geometry, material);\n\n    // Determine the initial position of the MMOD at random.\n    // Points on the surface of a sphere can be expressed using two\n    // spherical coordinates, theta and phi with 0 < theta < 2pi and\n    // 0 < phi < pi.\n    // Generate random values for theta and phi.\n    // const theta = Random.number(0.01, 2 * Math.PI);\n    // const phi = Math.acos(Random.number(-1, 1));\n    // TODO: Vary the radius slightly.\n    // Convert theta and phi into cartesian coordinates for the mesh.\n    // The LEO radius will be varied slightly by a modifier, targeting\n    // anywhere from 1000 km to 2000 km above the surface of the earth.\n    const threePosition = this.toThreeJSPosition();\n    this.mesh.position.x = threePosition.x; //LEO_RADIUS * Math.cos(theta) * Math.sin(phi);\n    this.mesh.position.y = threePosition.y; //LEO_RADIUS * Math.sin(theta) * Math.sin(phi);\n    this.mesh.position.z = threePosition.z; //LEO_RADIUS * Math.cos(phi);\n    this.mesh.scale.x = this.mesh.scale.y = this.mesh.scale.z = MMOD_SCALE;\n\n    // Set mean motion at random.\n    // Initial speed (scalar) should be anywhere from 6-9 km/s.\n    // const initialSpeed = Random.number(6000, 9000); // In m/s.\n    // // Convert this to approximate (non-elliptical) revolutions per day.\n    // const circumference = 46357.341; // 2pi * 7378 (mean LEO).\n    // const dayDistanceTraveled = initialSpeed * 86400; // Seconds in a day.\n    // this.motion = dayDistanceTraveled / circumference;\n\n    scene.add(this.mesh);\n  }\n\n  /**\n   * Proceed to the next animation frame. Reposition the\n   * @param timestamp Time in seconds since init. It's assumed that we init at 0.\n   */\n  public step(timestamp: number): void {\n    if (this.shouldLog) {\n      console.log(\n        \"Current position MMOD:\",\n        this.position.x,\n        this.position.y,\n        this.position.z,\n        ...Array.from(Object.values(this.toThreeJSPosition()))\n      );\n    }\n\n    // TODO: Move to constants!\n    // Logic to calculate new position based on timestamp.\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2.\n    const earthMass = 5.972e24; // Earth mass in kg.\n\n    // Convert timestamp to seconds.\n    const t = timestamp / 1000;\n\n    // Validate input values: semiMajorAxis should be positive, eccentricity should be between 0 and 1.\n    if (\n      this.orbit.semiMajorAxis <= 0 ||\n      this.orbit.eccentricity < 0 ||\n      this.orbit.eccentricity >= 1\n    ) {\n      console.error(\n        \"Invalid input values for semiMajorAxis or eccentricity.\",\n        this.orbit.semiMajorAxis,\n        this.orbit.eccentricity\n      );\n      return; // Exit function early to prevent further calculations with invalid inputs.\n    }\n\n    // Calculate mean anomaly (M) based on Kepler's equation.\n    const n = Math.sqrt(\n      (G * earthMass) / Math.pow(this.orbit.semiMajorAxis * 1000, 3)\n    ); // Mean motion.\n    let meanAnomaly = this.orbit.trueAnomalyAtEpoch - n * t;\n\n    // Iteratively solve Kepler's equation for eccentric anomaly (E).\n    let eccentricAnomaly = meanAnomaly; // Initial guess for eccentric anomaly.\n    let delta = 1;\n    const tolerance = 1e-10; // Tolerance for convergence.\n    while (Math.abs(delta) > tolerance) {\n      const f =\n        eccentricAnomaly -\n        this.orbit.eccentricity * Math.sin(eccentricAnomaly) -\n        meanAnomaly;\n      const fPrime = 1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly);\n      delta = f / fPrime;\n      eccentricAnomaly -= delta;\n    }\n\n    console.log(\"stuff 1\", meanAnomaly, eccentricAnomaly, delta);\n\n    // Calculate true anomaly (ν) from eccentric anomaly (E).\n    const trueAnomaly =\n      2 *\n      Math.atan(\n        Math.sqrt(\n          (1 + this.orbit.eccentricity) / (1 - this.orbit.eccentricity)\n        ) * Math.tan(eccentricAnomaly / 2)\n      );\n\n    // Calculate distance from center of the Earth to the satellite (r) using vis-viva equation.\n    const radius =\n      (this.orbit.semiMajorAxis *\n        (1 - this.orbit.eccentricity * this.orbit.eccentricity)) /\n      (1 + this.orbit.eccentricity * Math.cos(trueAnomaly));\n\n    // Calculate position in orbital plane (x', y').\n    const xPrime = radius * Math.cos(trueAnomaly);\n    const yPrime = radius * Math.sin(trueAnomaly);\n\n    console.log(trueAnomaly, radius, xPrime, yPrime);\n\n    // // Calculate true anomaly (ν) from eccentric anomaly (E).\n    // const cosTrueAnomaly =\n    //   (Math.cos(eccentricAnomaly) - this.orbit.eccentricity) /\n    //   (1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly));\n    // const sinTrueAnomaly =\n    //   (Math.sqrt(1 - this.orbit.eccentricity * this.orbit.eccentricity) *\n    //     Math.sin(eccentricAnomaly)) /\n    //   (1 - this.orbit.eccentricity * Math.cos(eccentricAnomaly));\n    // const trueAnomaly = Math.atan2(sinTrueAnomaly, cosTrueAnomaly);\n\n    // // Calculate distance from center of the Earth to the satellite (r) using vis-viva equation.\n    // const radius =\n    //   (this.orbit.semiMajorAxis *\n    //     1000 *\n    //     (1 - this.orbit.eccentricity * this.orbit.eccentricity)) /\n    //   (1 + this.orbit.eccentricity * Math.cos(trueAnomaly));\n\n    // // Calculate position in orbital plane (x', y').\n    // const xPrime = radius * Math.cos(trueAnomaly);\n    // const yPrime = radius * Math.sin(trueAnomaly);\n\n    // Rotate position to align with orbital elements.\n    const cosLongitudeAscendingNode = Math.cos(\n      this.orbit.longitudeAscendingNode\n    );\n    const sinLongitudeAscendingNode = Math.sin(\n      this.orbit.longitudeAscendingNode\n    );\n    const cosArgumentPeriapsis = Math.cos(this.orbit.argumentPeriapsis);\n    const sinArgumentPeriapsis = Math.sin(this.orbit.argumentPeriapsis);\n    const cosInclination = Math.cos(this.orbit.inclination);\n    const sinInclination = Math.sin(this.orbit.inclination);\n\n    console.log(\n      cosLongitudeAscendingNode,\n      sinLongitudeAscendingNode,\n      cosArgumentPeriapsis,\n      sinArgumentPeriapsis,\n      cosInclination,\n      sinInclination\n    );\n\n    const x =\n      xPrime *\n        (cosLongitudeAscendingNode * cosArgumentPeriapsis -\n          sinLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination) -\n      yPrime *\n        (sinLongitudeAscendingNode * cosArgumentPeriapsis +\n          cosLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination);\n    const y =\n      xPrime *\n        (cosLongitudeAscendingNode * sinArgumentPeriapsis +\n          sinLongitudeAscendingNode * cosArgumentPeriapsis * cosInclination) +\n      yPrime *\n        (cosLongitudeAscendingNode * cosArgumentPeriapsis -\n          sinLongitudeAscendingNode * sinArgumentPeriapsis * cosInclination);\n    const z =\n      xPrime * (sinLongitudeAscendingNode * sinInclination) +\n      yPrime * (cosLongitudeAscendingNode * sinInclination);\n\n    // Update object position.\n    this.position = { x, y, z };\n\n    // Finally, convert to three.js coordinate space and update the mesh's\n    // position.\n    const threePosition = this.toThreeJSPosition();\n\n    if (this.shouldLog) {\n      console.log(\n        \"New position for mmod:\",\n        this.position.x,\n        this.position.y,\n        this.position.z,\n        threePosition.x,\n        threePosition.y,\n        threePosition.z\n      );\n    }\n\n    // this.mesh.position.x = threePosition.x;\n    // this.mesh.position.y = threePosition.y;\n    // this.mesh.position.z = threePosition.z;\n  }\n\n  public tle(timestamp: Date): TLE {\n    // Line 1\n    const firstDerivativeMeanMotion = this.getFirstDerivativeMeanMotion();\n    const secondDerivativeMeanMotion = this.getSecondDerivativeMeanMotion();\n    const BSTARDragTerm = this.getBSTARDragTerm();\n    const line1 = `1 ${this.catalogNumber}U 00000A ${timestamp\n      .toISOString()\n      .slice(2, 10)\n      .replace(/-/g, \"\")} .${firstDerivativeMeanMotion\n      .toString()\n      .replace(/-/g, \" \")\n      .padStart(8, \" \")}${\n      secondDerivativeMeanMotion > 0\n        ? secondDerivativeMeanMotion.toFixed(8).padStart(8, \" \")\n        : \"  .00000000\"\n    }-${BSTARDragTerm.toFixed(4).replace(/-/g, \" \").padStart(6, \" \")} 0`;\n\n    // Line 2\n    const line2 = `2 ${this.catalogNumber} ${this.orbit.inclination\n      .toFixed(4)\n      .padStart(8, \" \")}${this.orbit.longitudeAscendingNode\n      .toFixed(4)\n      .padStart(8, \" \")}${(this.orbit.eccentricity * 1e7)\n      .toFixed(7)\n      .replace(/\\.?0+$/, \"\")\n      .padStart(7, \" \")}${this.orbit.argumentPeriapsis\n      .toFixed(4)\n      .padStart(8, \" \")}${this.getMeanAnomaly(timestamp.getUTCMilliseconds())\n      .toFixed(4)\n      .padStart(8, \" \")}${this.getMeanMotion(this.orbit.semiMajorAxis, MU_EARTH)\n      .toFixed(11)\n      .replace(\".\", \"\")}`;\n\n    return [line1, line2];\n  }\n\n  private getMeanMotion(a: number, mu: number): number {\n    // Semi-major axis 'a' in meters\n    // Gravitational parameter 'mu' in m^3/s^2\n\n    // Calculate mean motion (n)\n    const n = Math.sqrt(mu / Math.pow(a, 3));\n\n    // Convert mean motion to revolutions per day\n    const meanMotionRevPerDay = n * (86400 / (2 * Math.PI));\n\n    return meanMotionRevPerDay;\n  }\n\n  private getFirstDerivativeMeanMotion(): number {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Calculate the semi-major axis of the orbit in meters\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n\n    // Calculate the mean motion (n) in radians per second\n    const meanMotion = Math.sqrt(\n      (G * earthMass) / Math.pow(semiMajorAxisMeters, 3)\n    );\n\n    // Return the first derivative of mean motion\n    return -1.5 * meanMotion * this.orbit.eccentricity ** 2;\n  }\n\n  // Function to calculate the second derivative of mean motion\n  private getSecondDerivativeMeanMotion(): number {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Calculate the semi-major axis of the orbit in meters\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n\n    // Calculate the mean motion (n) in radians per second\n    const meanMotion = Math.sqrt(\n      (G * earthMass) / Math.pow(semiMajorAxisMeters, 3)\n    );\n\n    // Calculate the eccentricity squared\n    const eccentricitySquared =\n      this.orbit.eccentricity * this.orbit.eccentricity;\n\n    // Return the second derivative of mean motion\n    return (\n      (-meanMotion * eccentricitySquared * (4 * eccentricitySquared - 5)) /\n      semiMajorAxisMeters\n    );\n  }\n\n  private getBSTARDragTerm(): number {\n    // Constants\n    // TODO: Move to constants!\n    const earthRadius = 6371; // Earth radius in kilometers\n    const earthMass = 5.972e24; // Earth mass in kg\n    const dragCoefficient = 2.2; // Example drag coefficient\n\n    // Calculate the cross-sectional area of the object\n    const crossSectionalArea = Math.PI * Math.pow(this.diameter / 2, 2); // Assuming spherical object\n\n    // Calculate the ballistic coefficient\n    const ballisticCoefficient =\n      dragCoefficient * (crossSectionalArea / this.mass);\n\n    // Calculate the atmospheric density at the object's altitude\n    const altitudeFromEarthCenter = this.getPositionMagnitude() - earthRadius;\n    const altitudeFromSurface = altitudeFromEarthCenter - this.earthRadius;\n    const density = this.getAtmosphericDensity(altitudeFromSurface); // Example call to get atmospheric density\n\n    // Calculate the BSTAR drag term\n    return -0.5 * ballisticCoefficient * density;\n  }\n\n  private getMeanAnomaly(timestamp: number): number {\n    // Constants\n    const G = 6.6743e-11; // Gravitational constant in m^3/kg/s^2\n    const earthMass = 5.972e24; // Earth mass in kg\n\n    // Convert timestamp to seconds\n    const t = timestamp / 1000;\n\n    // Calculate mean motion (n) in radians per second\n    const semiMajorAxisMeters = this.orbit.semiMajorAxis * 1000;\n    const n = Math.sqrt((G * earthMass) / Math.pow(semiMajorAxisMeters, 3));\n\n    // Calculate mean anomaly (M) based on Kepler's equation\n    const M = this.orbit.trueAnomalyAtEpoch - n * t;\n\n    return M;\n  }\n\n  private getPositionMagnitude(): number {\n    return Math.sqrt(\n      this.position.x * this.position.x +\n        this.position.y * this.position.y +\n        this.position.z * this.position.z\n    );\n  }\n\n  // Function to estimate atmospheric density at a given altitude\n  private getAtmosphericDensity(altitude: number): number {\n    // Constants for US Standard Atmosphere model.\n    // NOTE: This is just for the troposphere (up to 11k km).\n    const T0 = 288.15; // Sea level temperature in Kelvin\n    const lapseRate = 0.0065; // Temperature lapse rate in Kelvin per meter\n    const R = 8.31447; // Universal gas constant in J/(mol*K)\n    const g0 = 9.80665; // Standard gravity in m/s^2\n    const M = 0.0289644; // Molar mass of dry air in kg/mol\n\n    // Calculate temperature at given altitude using lapse rate model.\n    const temperature = T0 - lapseRate * altitude;\n\n    // Calculate pressure at given altitude using hydrostatic equation.\n    const pressure =\n      101325 *\n      Math.pow(1 - (lapseRate * altitude) / T0, (g0 * M) / (R * lapseRate));\n\n    // Calculate density using ideal gas law.\n    return (pressure * M) / (R * temperature);\n  }\n\n  // Function to convert position to three.js coordinates\n  private toThreeJSPosition(): { x: number; y: number; z: number } {\n    // Scaling down the position to fit with three.js coordinates (assuming earth sphere radius is 16)\n    const scaleFactor = 6 / 6371; // TODO: Should be constants!\n    return {\n      x: this.position.x * scaleFactor,\n      y: this.position.y * scaleFactor,\n      z: this.position.z * scaleFactor,\n    };\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAAqBC,UAAU,QAAQ,sBAAsB;AAC7D,SAASC,MAAM,QAAQ,mBAAmB;AAI1C;AACA,MAAMC,oBAAoD,GAAG;EAC3DC,KAAK,EAAE,IAAI;EAAE;EACbC,OAAO,EAAE,GAAG;EAAE;EACdC,SAAS,EAAE,IAAI,CAAE;EACjB;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,QAAQ,GAAG,QAAQ;AAEzB,IAAIC,KAAK,GAAG,CAAC;AAEb,OAAO,MAAMC,IAAI,CAAC;EA0EhB;AACF;AACA;EACEC,WAAWA,CAACC,KAAkB,EAAE;IA5EhC;IAAA,KACgBC,IAAI;IAAA,KAEpBC,QAAQ;IAER;IACA;IACA;IAAA,KACOC,aAAa,GAAG,CAAC;IAExB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAAA,KACOC,UAAU,GAAG,CAAC;IACrB;IAAA,KACOC,cAAc,GAAoB,GAAG;IAE5C;IAAA,KACOC,KAAK;IAAA,KASLC,oBAAoB;IAE3B;IAAA,KACOC,MAAM;IAAU;IAAA,KAChBC,IAAI;IAAU;IAAA,KACdC,QAAQ;IAAU;IAAA,KAClBC,IAAI,GAAG,IAAI;IAAE;IAAA,KACbC,OAAO,GAAG,MAAM;IAAE;IAEzB;IAAA,KACAC,QAAQ;IAER;IACA;IAAA,KACAC,WAAW,GAAW,IAAI;IAAE;IAAA,KAE5BC,SAAS,GAAG,KAAK;IAMf;IACA,IAAIlB,KAAK,KAAK,CAAC,EAAE;MACf,IAAI,CAACkB,SAAS,GAAG,IAAI;IACvB;IACAlB,KAAK,EAAE;;IAEP;IACA,MAAMmB,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;IACzD,MAAMC,SAAS,GAAGH,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC;IACvC,MAAME,QAAQ,GAAGJ,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,EAAE,CAAC,CAAC;;IAE3C;IACA,MAAMG,CAAC,GACL,CAAC,IAAI,CAACR,WAAW,GAAGE,QAAQ,IAAIC,IAAI,CAACM,GAAG,CAACF,QAAQ,CAAC,GAAGJ,IAAI,CAACM,GAAG,CAACH,SAAS,CAAC;IAC1E,MAAMI,CAAC,GACL,CAAC,IAAI,CAACV,WAAW,GAAGE,QAAQ,IAAIC,IAAI,CAACM,GAAG,CAACF,QAAQ,CAAC,GAAGJ,IAAI,CAACQ,GAAG,CAACL,SAAS,CAAC;IAC1E,MAAMM,CAAC,GAAG,CAAC,IAAI,CAACZ,WAAW,GAAGE,QAAQ,IAAIC,IAAI,CAACQ,GAAG,CAACJ,QAAQ,CAAC;IAE5D,IAAI,CAACnB,QAAQ,GAAG;MAAEoB,CAAC;MAAEE,CAAC;MAAEE;IAAE,CAAC;;IAE3B;IACA,IAAI,CAACpB,KAAK,GAAG;MACXqB,aAAa,EAAEpC,MAAM,CAACqC,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC;MAAE;MACzCC,YAAY,EAAEtC,MAAM,CAACqC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC;MAEnC;MACA;MACA;MACAE,WAAW,EAAEvC,MAAM,CAACqC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC;MAAE;;MAEpC;MACAG,sBAAsB,EAAExC,MAAM,CAACqC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC;MAC7C;MACA;MACAI,iBAAiB,EAAEzC,MAAM,CAACqC,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC;MACxC;MACA;MACA;MACAK,kBAAkB,EAAE1C,MAAM,CAACqC,MAAM,CAAC,CAAC,EAAE,GAAG;IAC1C,CAAC;IAEDM,OAAO,CAACC,GAAG,CAAC,oBAAoB,EAAE,IAAI,CAAC7B,KAAK,CAAC;;IAE7C;IACA,IAAI,CAACO,QAAQ,GAAG,OAAO;IACvB,IAAI,CAACJ,IAAI,GAAGlB,MAAM,CAACqC,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC;IACvC,IAAI,CAAClB,QAAQ,GAAGnB,MAAM,CAACqC,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;IACvC,IAAI,CAACjB,IAAI,GAAGpB,MAAM,CAACqC,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAC;;IAErC,MAAMQ,eAAe,GAAG5C,oBAAoB,CAAC,IAAI,CAACqB,QAAQ,CAAC;IAC3D,IAAI,CAACD,OAAO,GAAGrB,MAAM,CAACqC,MAAM,CAACQ,eAAe,GAAG,GAAG,EAAEA,eAAe,GAAG,GAAG,CAAC,CAAC,CAAC;;IAE5E,IAAI,CAAC5B,MAAM,GAAI,CAAC,GAAG,CAAC,GAAIS,IAAI,CAACoB,EAAE,GAAGpB,IAAI,CAACqB,GAAG,CAAC,IAAI,CAAC5B,QAAQ,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;;IAElE;IACA,IAAI,CAACH,oBAAoB,GAAG,GAAG,GAAG,IAAI,CAACK,OAAO,GAAG,IAAI,CAACF,QAAQ,GAAG,IAAI,CAACC,IAAI;IAE1E,MAAM4B,QAAQ,GAAG,IAAIlD,KAAK,CAACmD,cAAc,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC;IACnD,MAAM3B,QAAQ,GAAG,IAAIxB,KAAK,CAACoD,iBAAiB,CAAC;MAC3CC,KAAK,EAAE,IAAIrD,KAAK,CAACsD,KAAK,CAAC,CAAC,CAACC,MAAM,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAEvD,KAAK,CAACwD,cAAc,CAAC;MACpEC,IAAI,EAAEzD,KAAK,CAAC0D,UAAU;MACtBC,eAAe,EAAE;IACnB,CAAC,CAAC;IACF,IAAI,CAAC/C,IAAI,GAAG,IAAIZ,KAAK,CAAC4D,IAAI,CAACV,QAAQ,EAAE1B,QAAQ,CAAC;;IAE9C;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,MAAMqC,aAAa,GAAG,IAAI,CAACC,iBAAiB,CAAC,CAAC;IAC9C,IAAI,CAAClD,IAAI,CAACC,QAAQ,CAACoB,CAAC,GAAG4B,aAAa,CAAC5B,CAAC,CAAC,CAAC;IACxC,IAAI,CAACrB,IAAI,CAACC,QAAQ,CAACsB,CAAC,GAAG0B,aAAa,CAAC1B,CAAC,CAAC,CAAC;IACxC,IAAI,CAACvB,IAAI,CAACC,QAAQ,CAACwB,CAAC,GAAGwB,aAAa,CAACxB,CAAC,CAAC,CAAC;IACxC,IAAI,CAACzB,IAAI,CAACmD,KAAK,CAAC9B,CAAC,GAAG,IAAI,CAACrB,IAAI,CAACmD,KAAK,CAAC5B,CAAC,GAAG,IAAI,CAACvB,IAAI,CAACmD,KAAK,CAAC1B,CAAC,GAAGpC,UAAU;;IAEtE;IACA;IACA;IACA;IACA;IACA;IACA;;IAEAU,KAAK,CAACqD,GAAG,CAAC,IAAI,CAACpD,IAAI,CAAC;EACtB;;EAEA;AACF;AACA;AACA;EACSqD,IAAIA,CAACC,SAAiB,EAAQ;IACnC,IAAI,IAAI,CAACxC,SAAS,EAAE;MAClBmB,OAAO,CAACC,GAAG,CACT,wBAAwB,EACxB,IAAI,CAACjC,QAAQ,CAACoB,CAAC,EACf,IAAI,CAACpB,QAAQ,CAACsB,CAAC,EACf,IAAI,CAACtB,QAAQ,CAACwB,CAAC,EACf,GAAG8B,KAAK,CAACC,IAAI,CAACC,MAAM,CAACC,MAAM,CAAC,IAAI,CAACR,iBAAiB,CAAC,CAAC,CAAC,CACvD,CAAC;IACH;;IAEA;IACA;IACA,MAAMS,CAAC,GAAG,UAAU,CAAC,CAAC;IACtB,MAAMC,SAAS,GAAG,QAAQ,CAAC,CAAC;;IAE5B;IACA,MAAMC,CAAC,GAAGP,SAAS,GAAG,IAAI;;IAE1B;IACA,IACE,IAAI,CAACjD,KAAK,CAACqB,aAAa,IAAI,CAAC,IAC7B,IAAI,CAACrB,KAAK,CAACuB,YAAY,GAAG,CAAC,IAC3B,IAAI,CAACvB,KAAK,CAACuB,YAAY,IAAI,CAAC,EAC5B;MACAK,OAAO,CAAC6B,KAAK,CACX,yDAAyD,EACzD,IAAI,CAACzD,KAAK,CAACqB,aAAa,EACxB,IAAI,CAACrB,KAAK,CAACuB,YACb,CAAC;MACD,OAAO,CAAC;IACV;;IAEA;IACA,MAAMmC,CAAC,GAAG/C,IAAI,CAACgD,IAAI,CAChBL,CAAC,GAAGC,SAAS,GAAI5C,IAAI,CAACqB,GAAG,CAAC,IAAI,CAAChC,KAAK,CAACqB,aAAa,GAAG,IAAI,EAAE,CAAC,CAC/D,CAAC,CAAC,CAAC;IACH,IAAIuC,WAAW,GAAG,IAAI,CAAC5D,KAAK,CAAC2B,kBAAkB,GAAG+B,CAAC,GAAGF,CAAC;;IAEvD;IACA,IAAIK,gBAAgB,GAAGD,WAAW,CAAC,CAAC;IACpC,IAAIE,KAAK,GAAG,CAAC;IACb,MAAMC,SAAS,GAAG,KAAK,CAAC,CAAC;IACzB,OAAOpD,IAAI,CAACqD,GAAG,CAACF,KAAK,CAAC,GAAGC,SAAS,EAAE;MAClC,MAAME,CAAC,GACLJ,gBAAgB,GAChB,IAAI,CAAC7D,KAAK,CAACuB,YAAY,GAAGZ,IAAI,CAACQ,GAAG,CAAC0C,gBAAgB,CAAC,GACpDD,WAAW;MACb,MAAMM,MAAM,GAAG,CAAC,GAAG,IAAI,CAAClE,KAAK,CAACuB,YAAY,GAAGZ,IAAI,CAACM,GAAG,CAAC4C,gBAAgB,CAAC;MACvEC,KAAK,GAAGG,CAAC,GAAGC,MAAM;MAClBL,gBAAgB,IAAIC,KAAK;IAC3B;IAEAlC,OAAO,CAACC,GAAG,CAAC,SAAS,EAAE+B,WAAW,EAAEC,gBAAgB,EAAEC,KAAK,CAAC;;IAE5D;IACA,MAAMK,WAAW,GACf,CAAC,GACDxD,IAAI,CAACyD,IAAI,CACPzD,IAAI,CAACgD,IAAI,CACP,CAAC,CAAC,GAAG,IAAI,CAAC3D,KAAK,CAACuB,YAAY,KAAK,CAAC,GAAG,IAAI,CAACvB,KAAK,CAACuB,YAAY,CAC9D,CAAC,GAAGZ,IAAI,CAAC0D,GAAG,CAACR,gBAAgB,GAAG,CAAC,CACnC,CAAC;;IAEH;IACA,MAAMS,MAAM,GACT,IAAI,CAACtE,KAAK,CAACqB,aAAa,IACtB,CAAC,GAAG,IAAI,CAACrB,KAAK,CAACuB,YAAY,GAAG,IAAI,CAACvB,KAAK,CAACuB,YAAY,CAAC,IACxD,CAAC,GAAG,IAAI,CAACvB,KAAK,CAACuB,YAAY,GAAGZ,IAAI,CAACM,GAAG,CAACkD,WAAW,CAAC,CAAC;;IAEvD;IACA,MAAMI,MAAM,GAAGD,MAAM,GAAG3D,IAAI,CAACM,GAAG,CAACkD,WAAW,CAAC;IAC7C,MAAMK,MAAM,GAAGF,MAAM,GAAG3D,IAAI,CAACQ,GAAG,CAACgD,WAAW,CAAC;IAE7CvC,OAAO,CAACC,GAAG,CAACsC,WAAW,EAAEG,MAAM,EAAEC,MAAM,EAAEC,MAAM,CAAC;;IAEhD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;;IAEA;IACA,MAAMC,yBAAyB,GAAG9D,IAAI,CAACM,GAAG,CACxC,IAAI,CAACjB,KAAK,CAACyB,sBACb,CAAC;IACD,MAAMiD,yBAAyB,GAAG/D,IAAI,CAACQ,GAAG,CACxC,IAAI,CAACnB,KAAK,CAACyB,sBACb,CAAC;IACD,MAAMkD,oBAAoB,GAAGhE,IAAI,CAACM,GAAG,CAAC,IAAI,CAACjB,KAAK,CAAC0B,iBAAiB,CAAC;IACnE,MAAMkD,oBAAoB,GAAGjE,IAAI,CAACQ,GAAG,CAAC,IAAI,CAACnB,KAAK,CAAC0B,iBAAiB,CAAC;IACnE,MAAMmD,cAAc,GAAGlE,IAAI,CAACM,GAAG,CAAC,IAAI,CAACjB,KAAK,CAACwB,WAAW,CAAC;IACvD,MAAMsD,cAAc,GAAGnE,IAAI,CAACQ,GAAG,CAAC,IAAI,CAACnB,KAAK,CAACwB,WAAW,CAAC;IAEvDI,OAAO,CAACC,GAAG,CACT4C,yBAAyB,EACzBC,yBAAyB,EACzBC,oBAAoB,EACpBC,oBAAoB,EACpBC,cAAc,EACdC,cACF,CAAC;IAED,MAAM9D,CAAC,GACLuD,MAAM,IACHE,yBAAyB,GAAGE,oBAAoB,GAC/CD,yBAAyB,GAAGE,oBAAoB,GAAGC,cAAc,CAAC,GACtEL,MAAM,IACHE,yBAAyB,GAAGC,oBAAoB,GAC/CF,yBAAyB,GAAGG,oBAAoB,GAAGC,cAAc,CAAC;IACxE,MAAM3D,CAAC,GACLqD,MAAM,IACHE,yBAAyB,GAAGG,oBAAoB,GAC/CF,yBAAyB,GAAGC,oBAAoB,GAAGE,cAAc,CAAC,GACtEL,MAAM,IACHC,yBAAyB,GAAGE,oBAAoB,GAC/CD,yBAAyB,GAAGE,oBAAoB,GAAGC,cAAc,CAAC;IACxE,MAAMzD,CAAC,GACLmD,MAAM,IAAIG,yBAAyB,GAAGI,cAAc,CAAC,GACrDN,MAAM,IAAIC,yBAAyB,GAAGK,cAAc,CAAC;;IAEvD;IACA,IAAI,CAAClF,QAAQ,GAAG;MAAEoB,CAAC;MAAEE,CAAC;MAAEE;IAAE,CAAC;;IAE3B;IACA;IACA,MAAMwB,aAAa,GAAG,IAAI,CAACC,iBAAiB,CAAC,CAAC;IAE9C,IAAI,IAAI,CAACpC,SAAS,EAAE;MAClBmB,OAAO,CAACC,GAAG,CACT,wBAAwB,EACxB,IAAI,CAACjC,QAAQ,CAACoB,CAAC,EACf,IAAI,CAACpB,QAAQ,CAACsB,CAAC,EACf,IAAI,CAACtB,QAAQ,CAACwB,CAAC,EACfwB,aAAa,CAAC5B,CAAC,EACf4B,aAAa,CAAC1B,CAAC,EACf0B,aAAa,CAACxB,CAChB,CAAC;IACH;;IAEA;IACA;IACA;EACF;EAEO2D,GAAGA,CAAC9B,SAAe,EAAO;IAC/B;IACA,MAAM+B,yBAAyB,GAAG,IAAI,CAACC,4BAA4B,CAAC,CAAC;IACrE,MAAMC,0BAA0B,GAAG,IAAI,CAACC,6BAA6B,CAAC,CAAC;IACvE,MAAMC,aAAa,GAAG,IAAI,CAACC,gBAAgB,CAAC,CAAC;IAC7C,MAAMC,KAAK,GAAI,KAAI,IAAI,CAACzF,aAAc,YAAWoD,SAAS,CACvDsC,WAAW,CAAC,CAAC,CACbC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CACZC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAE,KAAIT,yBAAyB,CAC/CU,QAAQ,CAAC,CAAC,CACVD,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAClBE,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAE,GAClBT,0BAA0B,GAAG,CAAC,GAC1BA,0BAA0B,CAACU,OAAO,CAAC,CAAC,CAAC,CAACD,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,GACtD,aACL,IAAGP,aAAa,CAACQ,OAAO,CAAC,CAAC,CAAC,CAACH,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAACE,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAE,IAAG;;IAEpE;IACA,MAAME,KAAK,GAAI,KAAI,IAAI,CAAChG,aAAc,IAAG,IAAI,CAACG,KAAK,CAACwB,WAAW,CAC5DoE,OAAO,CAAC,CAAC,CAAC,CACVD,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAE,GAAE,IAAI,CAAC3F,KAAK,CAACyB,sBAAsB,CACpDmE,OAAO,CAAC,CAAC,CAAC,CACVD,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAE,GAAE,CAAC,IAAI,CAAC3F,KAAK,CAACuB,YAAY,GAAG,GAAG,EACjDqE,OAAO,CAAC,CAAC,CAAC,CACVH,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CACrBE,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAE,GAAE,IAAI,CAAC3F,KAAK,CAAC0B,iBAAiB,CAC/CkE,OAAO,CAAC,CAAC,CAAC,CACVD,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAE,GAAE,IAAI,CAACG,cAAc,CAAC7C,SAAS,CAAC8C,kBAAkB,CAAC,CAAC,CAAC,CACtEH,OAAO,CAAC,CAAC,CAAC,CACVD,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAE,GAAE,IAAI,CAACK,aAAa,CAAC,IAAI,CAAChG,KAAK,CAACqB,aAAa,EAAE/B,QAAQ,CAAC,CACzEsG,OAAO,CAAC,EAAE,CAAC,CACXH,OAAO,CAAC,GAAG,EAAE,EAAE,CAAE,EAAC;IAErB,OAAO,CAACH,KAAK,EAAEO,KAAK,CAAC;EACvB;EAEQG,aAAaA,CAACC,CAAS,EAAEC,EAAU,EAAU;IACnD;IACA;;IAEA;IACA,MAAMxC,CAAC,GAAG/C,IAAI,CAACgD,IAAI,CAACuC,EAAE,GAAGvF,IAAI,CAACqB,GAAG,CAACiE,CAAC,EAAE,CAAC,CAAC,CAAC;;IAExC;IACA,MAAME,mBAAmB,GAAGzC,CAAC,IAAI,KAAK,IAAI,CAAC,GAAG/C,IAAI,CAACoB,EAAE,CAAC,CAAC;IAEvD,OAAOoE,mBAAmB;EAC5B;EAEQlB,4BAA4BA,CAAA,EAAW;IAC7C;IACA,MAAM3B,CAAC,GAAG,UAAU,CAAC,CAAC;IACtB,MAAMC,SAAS,GAAG,QAAQ,CAAC,CAAC;;IAE5B;IACA,MAAM6C,mBAAmB,GAAG,IAAI,CAACpG,KAAK,CAACqB,aAAa,GAAG,IAAI;;IAE3D;IACA,MAAMgF,UAAU,GAAG1F,IAAI,CAACgD,IAAI,CACzBL,CAAC,GAAGC,SAAS,GAAI5C,IAAI,CAACqB,GAAG,CAACoE,mBAAmB,EAAE,CAAC,CACnD,CAAC;;IAED;IACA,OAAO,CAAC,GAAG,GAAGC,UAAU,GAAG,IAAI,CAACrG,KAAK,CAACuB,YAAY,IAAI,CAAC;EACzD;;EAEA;EACQ4D,6BAA6BA,CAAA,EAAW;IAC9C;IACA,MAAM7B,CAAC,GAAG,UAAU,CAAC,CAAC;IACtB,MAAMC,SAAS,GAAG,QAAQ,CAAC,CAAC;;IAE5B;IACA,MAAM6C,mBAAmB,GAAG,IAAI,CAACpG,KAAK,CAACqB,aAAa,GAAG,IAAI;;IAE3D;IACA,MAAMgF,UAAU,GAAG1F,IAAI,CAACgD,IAAI,CACzBL,CAAC,GAAGC,SAAS,GAAI5C,IAAI,CAACqB,GAAG,CAACoE,mBAAmB,EAAE,CAAC,CACnD,CAAC;;IAED;IACA,MAAME,mBAAmB,GACvB,IAAI,CAACtG,KAAK,CAACuB,YAAY,GAAG,IAAI,CAACvB,KAAK,CAACuB,YAAY;;IAEnD;IACA,OACG,CAAC8E,UAAU,GAAGC,mBAAmB,IAAI,CAAC,GAAGA,mBAAmB,GAAG,CAAC,CAAC,GAClEF,mBAAmB;EAEvB;EAEQf,gBAAgBA,CAAA,EAAW;IACjC;IACA;IACA,MAAM7E,WAAW,GAAG,IAAI,CAAC,CAAC;IAC1B,MAAM+C,SAAS,GAAG,QAAQ,CAAC,CAAC;IAC5B,MAAMgD,eAAe,GAAG,GAAG,CAAC,CAAC;;IAE7B;IACA,MAAMC,kBAAkB,GAAG7F,IAAI,CAACoB,EAAE,GAAGpB,IAAI,CAACqB,GAAG,CAAC,IAAI,CAAC5B,QAAQ,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;;IAErE;IACA,MAAMH,oBAAoB,GACxBsG,eAAe,IAAIC,kBAAkB,GAAG,IAAI,CAACrG,IAAI,CAAC;;IAEpD;IACA,MAAMsG,uBAAuB,GAAG,IAAI,CAACC,oBAAoB,CAAC,CAAC,GAAGlG,WAAW;IACzE,MAAMmG,mBAAmB,GAAGF,uBAAuB,GAAG,IAAI,CAACjG,WAAW;IACtE,MAAMF,OAAO,GAAG,IAAI,CAACsG,qBAAqB,CAACD,mBAAmB,CAAC,CAAC,CAAC;;IAEjE;IACA,OAAO,CAAC,GAAG,GAAG1G,oBAAoB,GAAGK,OAAO;EAC9C;EAEQwF,cAAcA,CAAC7C,SAAiB,EAAU;IAChD;IACA,MAAMK,CAAC,GAAG,UAAU,CAAC,CAAC;IACtB,MAAMC,SAAS,GAAG,QAAQ,CAAC,CAAC;;IAE5B;IACA,MAAMC,CAAC,GAAGP,SAAS,GAAG,IAAI;;IAE1B;IACA,MAAMmD,mBAAmB,GAAG,IAAI,CAACpG,KAAK,CAACqB,aAAa,GAAG,IAAI;IAC3D,MAAMqC,CAAC,GAAG/C,IAAI,CAACgD,IAAI,CAAEL,CAAC,GAAGC,SAAS,GAAI5C,IAAI,CAACqB,GAAG,CAACoE,mBAAmB,EAAE,CAAC,CAAC,CAAC;;IAEvE;IACA,MAAMS,CAAC,GAAG,IAAI,CAAC7G,KAAK,CAAC2B,kBAAkB,GAAG+B,CAAC,GAAGF,CAAC;IAE/C,OAAOqD,CAAC;EACV;EAEQH,oBAAoBA,CAAA,EAAW;IACrC,OAAO/F,IAAI,CAACgD,IAAI,CACd,IAAI,CAAC/D,QAAQ,CAACoB,CAAC,GAAG,IAAI,CAACpB,QAAQ,CAACoB,CAAC,GAC/B,IAAI,CAACpB,QAAQ,CAACsB,CAAC,GAAG,IAAI,CAACtB,QAAQ,CAACsB,CAAC,GACjC,IAAI,CAACtB,QAAQ,CAACwB,CAAC,GAAG,IAAI,CAACxB,QAAQ,CAACwB,CACpC,CAAC;EACH;;EAEA;EACQwF,qBAAqBA,CAAClG,QAAgB,EAAU;IACtD;IACA;IACA,MAAMoG,EAAE,GAAG,MAAM,CAAC,CAAC;IACnB,MAAMC,SAAS,GAAG,MAAM,CAAC,CAAC;IAC1B,MAAMC,CAAC,GAAG,OAAO,CAAC,CAAC;IACnB,MAAMC,EAAE,GAAG,OAAO,CAAC,CAAC;IACpB,MAAMJ,CAAC,GAAG,SAAS,CAAC,CAAC;;IAErB;IACA,MAAMK,WAAW,GAAGJ,EAAE,GAAGC,SAAS,GAAGrG,QAAQ;;IAE7C;IACA,MAAMyG,QAAQ,GACZ,MAAM,GACNxG,IAAI,CAACqB,GAAG,CAAC,CAAC,GAAI+E,SAAS,GAAGrG,QAAQ,GAAIoG,EAAE,EAAGG,EAAE,GAAGJ,CAAC,IAAKG,CAAC,GAAGD,SAAS,CAAC,CAAC;;IAEvE;IACA,OAAQI,QAAQ,GAAGN,CAAC,IAAKG,CAAC,GAAGE,WAAW,CAAC;EAC3C;;EAEA;EACQrE,iBAAiBA,CAAA,EAAwC;IAC/D;IACA,MAAMuE,WAAW,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC;IAC9B,OAAO;MACLpG,CAAC,EAAE,IAAI,CAACpB,QAAQ,CAACoB,CAAC,GAAGoG,WAAW;MAChClG,CAAC,EAAE,IAAI,CAACtB,QAAQ,CAACsB,CAAC,GAAGkG,WAAW;MAChChG,CAAC,EAAE,IAAI,CAACxB,QAAQ,CAACwB,CAAC,GAAGgG;IACvB,CAAC;EACH;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}